From 6099aa13d2f184c2e0228256932793284e1f7687 Mon Sep 17 00:00:00 2001
From: Baozhu Zuo <zuobaozhu@gmail.com>
Date: Tue, 29 Aug 2017 18:51:10 +0800
Subject: [PATCH 2/3] Volume adjust support every channels

---
 sound/soc/codecs/ac108.c | 222 ++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 169 insertions(+), 53 deletions(-)

diff --git a/sound/soc/codecs/ac108.c b/sound/soc/codecs/ac108.c
index dad5cee..5f165fc 100644
--- a/sound/soc/codecs/ac108.c
+++ b/sound/soc/codecs/ac108.c
@@ -8,7 +8,7 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-#define DEBUG 1
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -58,7 +58,7 @@ struct ac108_priv {
 	unsigned char *init_regs;
 	int reg_length;
 };
-static struct ac108_priv *ac108;
+static struct ac108_priv *ac108_global;
 
 struct real_val_to_reg_val {
 	unsigned int real_val;
@@ -261,6 +261,7 @@ static const  unsigned int ac108_data_source_values[] = {
 	0x08,
 	0x00,
 };
+
 static SOC_VALUE_ENUM_SINGLE_DECL(ac108_tx1_channel_low_enum,
 								  I2S_TX1_CTRL2, 0, 0xff,
 								  ac108_channel_low_enable_texts,
@@ -394,23 +395,6 @@ static const struct snd_kcontrol_new ac108_snd_controls[] = {
 	/*0x42:TX2 Channel1 ~Channel8 (slot) enable*/
 	SOC_ENUM("TX2 Channel9~16 enable", ac108_tx2_channel_high_enum),
 #endif
-	/*0x70: ADC1 Digital Channel Volume Control Register*/
-	SOC_SINGLE_TLV("CH1 digital volume", ADC1_DVOL_CTRL, 0, 0xff, 0, ch1_digital_vol_tlv),
-	/*0x71: ADC2 Digital Channel Volume Control Register*/
-	SOC_SINGLE_TLV("CH2 digital volume", ADC2_DVOL_CTRL, 0, 0xff, 0, ch2_digital_vol_tlv),
-	/*0x72: ADC3 Digital Channel Volume Control Register*/
-	SOC_SINGLE_TLV("CH3 digital volume", ADC3_DVOL_CTRL, 0, 0xff, 0, ch3_digital_vol_tlv),
-	/*0x73: ADC4 Digital Channel Volume Control Register*/
-	SOC_SINGLE_TLV("CH4 digital volume", ADC4_DVOL_CTRL, 0, 0xff, 0, ch4_digital_vol_tlv),
-
-	/*0x90: Analog PGA1 Control Register*/
-	SOC_SINGLE_TLV("ADC1 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, adc1_pga_gain_tlv),
-	/*0x91: Analog PGA2 Control Register*/
-	SOC_SINGLE_TLV("ADC2 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, adc2_pga_gain_tlv),
-	/*0x92: Analog PGA3 Control Register*/
-	SOC_SINGLE_TLV("ADC3 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, adc3_pga_gain_tlv),
-	/*0x93: Analog PGA4 Control Register*/
-	SOC_SINGLE_TLV("ADC4 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, adc4_pga_gain_tlv),
 
 	/*0x96-0x9F: use the default value*/
 #if 0
@@ -611,6 +595,7 @@ static int ac108_write(u8 reg, unsigned char val, struct i2c_client *client) {
 	return 0;
 }
 
+
 static int ac108_update_bits(u8 reg, u8 mask, u8 val, struct i2c_client *client) {
 	u8 val_old, val_new;
 
@@ -623,6 +608,133 @@ static int ac108_update_bits(u8 reg, u8 mask, u8 val, struct i2c_client *client)
 	return 0;
 }
 
+/**
+ * snd_ac108_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_ac108_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol){
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	int chip = mc->autodisable;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	u8 val;
+	int ret;
+
+	ret = ac108_read(reg, &val, ac108_global->i2c[chip]);
+
+	if (ret < 0)
+		return ret;
+
+	val = (val >> shift) & mask;
+
+	ucontrol->value.integer.value[0] = val - min;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+/**
+ * snd_ac108_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_ac108_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol){
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	unsigned int sign_bit = mc->sign_bit;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	int err;
+	unsigned int val, val_mask;
+	int chip = mc->autodisable;
+
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+
+	err = ac108_update_bits(reg, val_mask, val, ac108_global->i2c[chip]);
+	if (err < 0)
+		return err;
+
+
+	return err;
+}
+#define SOC_AC108_SINGLE_TLV(xname, reg, shift, max, invert, chip, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, .get = snd_ac108_get_volsw,\
+	.put = snd_ac108_put_volsw, \
+	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, chip) }
+
+static const struct snd_kcontrol_new ac108_volume_snd_controls[] = {
+	/*0x70: ADC1 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH1 volume", ADC1_DVOL_CTRL, 0, 0xff, 0, 0, ch1_digital_vol_tlv),
+	/*0x71: ADC2 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH2 volume", ADC2_DVOL_CTRL, 0, 0xff, 0, 0, ch2_digital_vol_tlv),
+	/*0x72: ADC3 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH3 volume", ADC3_DVOL_CTRL, 0, 0xff, 0, 0, ch3_digital_vol_tlv),
+	/*0x73: ADC4 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH4 volume", ADC4_DVOL_CTRL, 0, 0xff, 0, 0, ch4_digital_vol_tlv),
+
+	/*0x90: Analog PGA1 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC1 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, 0, adc1_pga_gain_tlv),
+	/*0x91: Analog PGA2 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC2 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, 0, adc2_pga_gain_tlv),
+	/*0x92: Analog PGA3 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC3 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, 0, adc3_pga_gain_tlv),
+	/*0x93: Analog PGA4 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC4 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, 0, adc4_pga_gain_tlv),
+
+	/*0x70: ADC1 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH5 volume", ADC1_DVOL_CTRL, 0, 0xff, 0, 1, ch1_digital_vol_tlv),
+	/*0x71: ADC2 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH6 volume", ADC2_DVOL_CTRL, 0, 0xff, 0, 1, ch2_digital_vol_tlv),
+	/*0x72: ADC3 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH7 volume", ADC3_DVOL_CTRL, 0, 0xff, 0, 1, ch3_digital_vol_tlv),
+	/*0x73: ADC4 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH8 volume", ADC4_DVOL_CTRL, 0, 0xff, 0, 1, ch4_digital_vol_tlv),
+
+	/*0x90: Analog PGA1 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC5 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, 1, adc1_pga_gain_tlv),
+	/*0x91: Analog PGA2 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC6 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, 1, adc2_pga_gain_tlv),
+	/*0x92: Analog PGA3 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC7 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, 1, adc3_pga_gain_tlv),
+	/*0x93: Analog PGA4 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC8 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, 1, adc4_pga_gain_tlv),
+};
+
+
 static int ac108_multi_chips_read(u8 reg, u8 *rt_value, struct ac108_priv *ac108) {
 	u8 i;
 	for (i = 0; i < ac108->codec_index; i++) {
@@ -714,7 +826,6 @@ static int ac108_configure_clocking(struct ac108_priv *ac108, unsigned int rate)
 		for (i = 0; i < ARRAY_SIZE(ac108_pll_div_list); i++) {
 			if (ac108_pll_div_list[i].freq_in == ac108->sysclk && ac108_pll_div_list[i].freq_out % rate == 0) {
 				ac108_pll_div = ac108_pll_div_list[i];
-				pr_info("AC108 PLL freq_in match:%u, freq_out:%u\n\n", ac108_pll_div.freq_in, ac108_pll_div.freq_out);
 				break;
 			}
 		}
@@ -779,7 +890,7 @@ static int ac108_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_h
 		sample_resolution = 6;
 		break;
 	default:
-		pr_err("AC108 don't supported the sample resolution: %u\n", params_format(params));
+		dev_err(codec->dev, "AC108 don't supported the sample resolution: %u\n", params_format(params));
 		return -EINVAL;
 	}
 
@@ -790,7 +901,11 @@ static int ac108_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_h
 			break;
 		}
 	}
-	if (rate == 99) return -EINVAL;
+	if (rate == 99) {
+		dev_err(codec->dev, "unsupported rate %d\n",
+			params_rate(params));
+		return -EINVAL;
+	}
 
 
 	dev_dbg(dai->dev, "rate: %d , channels: %d , sample_resolution: %d",
@@ -860,7 +975,6 @@ static int ac108_set_sysclk(struct snd_soc_dai *dai, int clk_id, unsigned int fr
 
 	struct ac108_priv *ac108 = snd_soc_dai_get_drvdata(dai);
 
-	pr_info("%s  :%d\n", __FUNCTION__, freq);
 	switch (clk_id) {
 	case SYSCLK_SRC_MCLK:
 		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_SRC, SYSCLK_SRC_MCLK << SYSCLK_SRC, ac108);
@@ -1106,6 +1220,8 @@ static int ac108_add_widgets(struct snd_soc_codec *codec) {
 	snd_soc_add_codec_controls(codec, ac108_snd_controls,
 							   ARRAY_SIZE(ac108_snd_controls));
 
+	snd_soc_add_codec_controls(codec, ac108_volume_snd_controls,
+						   ARRAY_SIZE(ac108_volume_snd_controls));
 
 	snd_soc_dapm_new_controls(dapm, ac108_dapm_widgets,
 							  ARRAY_SIZE(ac108_dapm_widgets));
@@ -1117,22 +1233,22 @@ static int ac108_add_widgets(struct snd_soc_codec *codec) {
 static int ac108_probe(struct snd_soc_codec *codec) {
 
 	int ret;
-	dev_set_drvdata(codec->dev, ac108);
+	dev_set_drvdata(codec->dev, ac108_global);
 	ac108_add_widgets(codec);
 
-	ac108->mclk = devm_clk_get(codec->dev, "mclk");
-	if (IS_ERR(ac108->mclk)) {
+	ac108_global->mclk = devm_clk_get(codec->dev, "mclk");
+	if (IS_ERR(ac108_global->mclk)) {
 		dev_err(codec->dev, "%s mclk is missing or invalid\n", __func__);
-		return PTR_ERR(ac108->mclk);
+		return PTR_ERR(ac108_global->mclk);
 	}
-	ret = clk_prepare_enable(ac108->mclk);
+	ret = clk_prepare_enable(ac108_global->mclk);
 	if (ret)
 		return ret;
 
-	ac108->sysclk = clk_get_rate(ac108->mclk);
-	ac108->clk_id = SYSCLK_SRC_PLL;
+	ac108_global->sysclk = clk_get_rate(ac108_global->mclk);
+	ac108_global->clk_id = SYSCLK_SRC_PLL;
 
-	pr_info("ac108 mclk is %d\n", ac108->sysclk);
+	pr_info("ac108 mclk is %d\n", ac108_global->sysclk);
 	return 0;
 }
 
@@ -1186,7 +1302,7 @@ static ssize_t ac108_store(struct device *dev, struct device_attribute *attr, co
 	if (flag) {
 		reg = (val >> 8) & 0xFF;
 		value_w = val & 0xFF;
-		ac108_multi_chips_write(reg, value_w, ac108);
+		ac108_multi_chips_write(reg, value_w, ac108_global);
 		printk("Write 0x%02x to REG:0x%02x\n", value_w, reg);
 	} else {
 		reg = (val >> 8) & 0xFF;
@@ -1195,7 +1311,7 @@ static ssize_t ac108_store(struct device *dev, struct device_attribute *attr, co
 
 		do {
 			value_r = 0;
-			ac108_multi_chips_read(reg, &value_r, ac108);
+			ac108_multi_chips_read(reg, &value_r, ac108_global);
 			printk("REG[0x%02x]: 0x%02x;  ", reg, value_r);
 			reg++;
 			i++;
@@ -1242,35 +1358,34 @@ static int ac108_i2c_probe(struct i2c_client *i2c,
 	unsigned int val = 0;
 	int ii;
 
-	if (ac108 == NULL) {
-		ac108 = devm_kzalloc(&i2c->dev, sizeof(struct ac108_priv), GFP_KERNEL);
-		if (ac108 == NULL) {
+	if (ac108_global == NULL) {
+		ac108_global = devm_kzalloc(&i2c->dev, sizeof(struct ac108_priv), GFP_KERNEL);
+		if (ac108_global == NULL) {
 			dev_err(&i2c->dev, "Unable to allocate ac108 private data\n");
 			return -ENOMEM;
 		}
 	}
 
-	if (!of_find_property(np, "init-data", &ac108->reg_length)){
+	if (!of_find_property(np, "init-data", &ac108_global->reg_length)){
 		pr_err(" error init-data not property!!!\n");
-		ac108->reg_length = 0;
+		ac108_global->reg_length = 0;
 	}
 
 
-	ac108->reg_length = ac108->reg_length / sizeof(u8);
+	ac108_global->reg_length = ac108_global->reg_length / sizeof(u8);
 
-	printk("length:%d.\n",ac108->reg_length);
 	/* read max_num from DT property */
-	if (ac108->reg_length > 0) {
+	if (ac108_global->reg_length > 0) {
 	
-		ac108->init_regs = (unsigned char *)vmalloc(ac108->reg_length);
-		if (!ac108->init_regs){
-			printk("<ac108->init_regs> error vmalloc failed!!!\n");
+		ac108_global->init_regs = (unsigned char *)vmalloc(ac108_global->reg_length);
+		if (!ac108_global->init_regs){
+			dev_err(&i2c->dev,"<ac108->init_regs> error vmalloc failed!!!\n");
 			return -ENOMEM;
 		}
 
-		ret = of_property_read_u8_array(np,"init-data",ac108->init_regs,ac108->reg_length);
+		ret = of_property_read_u8_array(np,"init-data",ac108_global->init_regs,ac108_global->reg_length);
 		if (ret != 0){
-			printk(" of_property_read_u8_array failed!!!\n");
+			dev_err(&i2c->dev," of_property_read_u8_array failed!!!\n");
 			return -EINVAL;
 		}
 	} else
@@ -1282,26 +1397,26 @@ static int ac108_i2c_probe(struct i2c_client *i2c,
 		pr_err("Please set data-protocol.\n");
 		return -EINVAL;
 	}
-	ac108->data_protocol = val;
+	ac108_global->data_protocol = val;
 
 
 	pr_err(" i2c_id number :%d\n", (int)(i2c_id->driver_data));
-	pr_err(" ac108  codec_index :%d\n", ac108->codec_index);
-	pr_err(" ac108  I2S data protocol type :%d\n", ac108->data_protocol);
+	pr_err(" ac108  codec_index :%d\n", ac108_global->codec_index);
+	pr_err(" ac108  I2S data protocol type :%d\n", ac108_global->data_protocol);
 
-	ac108->i2c[i2c_id->driver_data] = i2c;
+	ac108_global->i2c[i2c_id->driver_data] = i2c;
 	ret = snd_soc_register_codec(&i2c->dev, &ac108_soc_codec_driver, ac108_dai[i2c_id->driver_data], 1);
 	if (ret < 0) {
 		dev_err(&i2c->dev, "Failed to register ac108 codec: %d\n", ret);
 	}
-	ac108->codec_index++;
+	ac108_global->codec_index++;
 
 	/*Writing this register 0x12 resets all register to their default state.*/
 	ac108_write(CHIP_RST, CHIP_RST_VAL, i2c);
 
 	/*if ac108 has init data,write now*/
-	for (ii = 0; ii < ac108->reg_length-1;ii+=2) {
-		ac108_write(ac108->init_regs[ii],ac108->init_regs[ii+1],i2c);
+	for (ii = 0; ii < ac108_global->reg_length-1;ii+=2) {
+		ac108_write(ac108_global->init_regs[ii],ac108_global->init_regs[ii+1],i2c);
 	}
 
 	ret = sysfs_create_group(&i2c->dev.kobj, &ac108_debug_attr_group);
@@ -1350,3 +1465,4 @@ module_i2c_driver(ac108_i2c_driver);
 MODULE_DESCRIPTION("ASoC AC108 driver");
 MODULE_AUTHOR("Baozhu Zuo<zuobaozhu@gmail.com>");
 MODULE_LICENSE("GPL");
+
-- 
2.7.4

