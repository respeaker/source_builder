From 66f355a00086cba729910984ca6d477aaa27c9d1 Mon Sep 17 00:00:00 2001
From: Baozhu Zuo <zuobaozhu@gmail.com>
Date: Fri, 22 Sep 2017 17:36:56 +0800
Subject: [PATCH 5/5] sound: soc: codecs: use xpower ac108 linux drivers

---
 sound/soc/codecs/ac108.c | 3244 +++++++++++++++++++++++++---------------------
 sound/soc/codecs/ac108.h | 1584 +++++++++++-----------
 2 files changed, 2586 insertions(+), 2242 deletions(-)

diff --git a/sound/soc/codecs/ac108.c b/sound/soc/codecs/ac108.c
index 9f0c51e..e2240d3 100644
--- a/sound/soc/codecs/ac108.c
+++ b/sound/soc/codecs/ac108.c
@@ -1,1468 +1,1776 @@
-/*
- * ac108.c  --  ac108 ALSA SoC Audio driver
- *
- *
- * Author: Baozhu Zuo<zuobaozhu@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pm.h>
-#include <linux/clk.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/initval.h>
-#include <sound/tlv.h>
-#include <linux/vmalloc.h>
-
-
-#include "ac108.h"
-
-/**
- * TODO: 
- * 1, add PM API:  ac108_suspend,ac108_resume 
- * 2, add set_pll ,set_clkdiv 
- * 3,0x65-0x6a 
- * 4,0x76-0x79 high 4bit 
- */
-struct pll_div {
-	unsigned int freq_in;
-	unsigned int freq_out;
-	unsigned int m1;
-	unsigned int m2;
-	unsigned int n;
-	unsigned int k1;
-	unsigned int k2;
-};
-
-
-struct ac108_priv {
-	struct i2c_client *i2c[4];
-	int codec_index;
-	int sysclk;
-	int clk_id;
-	struct clk *mclk;
-	unsigned char i2s_mode;
-	unsigned char data_protocol;
-
-	unsigned char *init_regs;
-	int reg_length;
-};
-static struct ac108_priv *ac108_global;
-
-struct real_val_to_reg_val {
-	unsigned int real_val;
-	unsigned int reg_val;
-};
-
-static const struct real_val_to_reg_val ac108_sample_rate[] = {
-	{ 8000,  0 },
-	{ 11025, 1 },
-	{ 12000, 2 },
-	{ 16000, 3 },
-	{ 22050, 4 },
-	{ 24000, 5 },
-	{ 32000, 6 },
-	{ 44100, 7 },
-	{ 48000, 8 },
-	{ 96000, 9 },
-};
-
-static const struct real_val_to_reg_val ac108_sample_resolution[] = {
-	{ 8,  1 },
-	{ 12, 2 },
-	{ 16, 3 },
-	{ 20, 4 },
-	{ 24, 5 },
-	{ 28, 6 },
-	{ 32, 7 },
-};
-
-/* FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] ;	M1[0,31],  M2[0,1],  N[0,1023],  K1[0,31],  K2[0,1] */
-static const struct pll_div ac108_pll_div_list[] = {
-	{ 400000,   24576000, 0,  0, 614, 4, 1 },
-	{ 512000,   24576000, 0,  0, 960, 9, 1 }, //24576000/48
-	{ 768000,   24576000, 0,  0, 640, 9, 1 }, //24576000/32
-	{ 800000,   24576000, 0,  0, 614, 9, 1 },
-	{ 1024000,  24576000, 0,  0, 480, 9, 1 }, //24576000/24
-	{ 1600000,  24576000, 0,  0, 307, 9, 1 },
-	{ 2048000,  24576000, 0,  0, 240, 9, 1 }, //24576000/12
-	{ 3072000,  24576000, 0,  0, 160, 9, 1 }, //24576000/8
-	{ 4096000,  24576000, 2,  0, 360, 9, 1 }, //24576000/6
-	{ 6000000,  24576000, 4,  0, 410, 9, 1 },
-	{ 12000000, 24576000, 9,  0, 410, 9, 1 },
-	{ 13000000, 24576000, 8,  0, 340, 9, 1 },
-	{ 15360000, 24576000, 12, 0, 415, 9, 1 },
-	{ 16000000, 24576000, 12, 0, 400, 9, 1 },
-	{ 19200000, 24576000, 15, 0, 410, 9, 1 },
-	{ 19680000, 24576000, 15, 0, 400, 9, 1 },
-	{ 24000000, 24576000, 9,  0, 205, 9, 1 },
-
-	{ 400000,   22579200, 0,  0, 566, 4, 1 },
-	{ 512000,   22579200, 0,  0, 880, 9, 1 },
-	{ 768000,   22579200, 0,  0, 587, 9, 1 },
-	{ 800000,   22579200, 0,  0, 567, 9, 1 },
-	{ 1024000,  22579200, 0,  0, 440, 9, 1 },
-	{ 1600000,  22579200, 1,  0, 567, 9, 1 },
-	{ 2048000,  22579200, 0,  0, 220, 9, 1 },
-	{ 3072000,  22579200, 0,  0, 148, 9, 1 },
-	{ 4096000,  22579200, 2,  0, 330, 9, 1 },
-	{ 6000000,  22579200, 2,  0, 227, 9, 1 },
-	{ 12000000, 22579200, 8,  0, 340, 9, 1 },
-	{ 13000000, 22579200, 9,  0, 350, 9, 1 },
-	{ 15360000, 22579200, 10, 0, 325, 9, 1 },
-	{ 16000000, 22579200, 11, 0, 340, 9, 1 },
-	{ 19200000, 22579200, 13, 0, 330, 9, 1 },
-	{ 19680000, 22579200, 14, 0, 345, 9, 1 },
-	{ 24000000, 22579200, 16, 0, 320, 9, 1 },
-
-	{ 12288000, 24576000, 9,  0, 400, 9, 1 }, //24576000/2
-	{ 11289600, 22579200, 9,  0, 400, 9, 1 }, //22579200/2
-
-	{ 24576000 / 1,   24576000, 9,  0, 200, 9, 1 }, //24576000
-	{ 24576000 / 4,   24576000, 4,  0, 400, 9, 1 }, //6144000
-	{ 24576000 / 16,  24576000, 0,  0, 320, 9, 1 }, //1536000
-	{ 24576000 / 64,  24576000, 0,  0, 640, 4, 1 }, //384000
-	{ 24576000 / 96,  24576000, 0,  0, 960, 4, 1 }, //256000
-	{ 24576000 / 128, 24576000, 0,  0, 512, 1, 1 }, //192000
-	{ 24576000 / 176, 24576000, 0,  0, 880, 4, 0 }, //140000
-	{ 24576000 / 192, 24576000, 0,  0, 960, 4, 0 }, //128000
-
-	{ 22579200 / 1,   22579200, 9,  0, 200, 9, 1 }, //22579200
-	{ 22579200 / 4,   22579200, 4,  0, 400, 9, 1 }, //5644800
-	{ 22579200 / 16,  22579200, 0,  0, 320, 9, 1 }, //1411200
-	{ 22579200 / 64,  22579200, 0,  0, 640, 4, 1 }, //352800
-	{ 22579200 / 96,  22579200, 0,  0, 960, 4, 1 }, //235200
-	{ 22579200 / 128, 22579200, 0,  0, 512, 1, 1 }, //176400
-	{ 22579200 / 176, 22579200, 0,  0, 880, 4, 0 }, //128290
-	{ 22579200 / 192, 22579200, 0,  0, 960, 4, 0 }, //117600
-
-	{ 22579200 / 6,   22579200, 2,  0, 360, 9, 1 }, //3763200
-	{ 22579200 / 8,   22579200, 0,  0, 160, 9, 1 }, //2822400
-	{ 22579200 / 12,  22579200, 0,  0, 240, 9, 1 }, //1881600
-	{ 22579200 / 24,  22579200, 0,  0, 480, 9, 1 }, //940800
-	{ 22579200 / 32,  22579200, 0,  0, 640, 9, 1 }, //705600
-	{ 22579200 / 48,  22579200, 0,  0, 960, 9, 1 }, //470400
-};
-
-
-
-//AC108 define
-#define AC108_CHANNELS_MAX		8		//range[1, 16]
-#define AC108_RATES 			(SNDRV_PCM_RATE_8000_96000 | SNDRV_PCM_RATE_KNOT)
-#define AC108_FORMATS			(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
-
-static const DECLARE_TLV_DB_SCALE(adc1_pga_gain_tlv, 0, 100, 0);
-static const DECLARE_TLV_DB_SCALE(adc2_pga_gain_tlv, 0, 100, 0);
-static const DECLARE_TLV_DB_SCALE(adc3_pga_gain_tlv, 0, 100, 0);
-static const DECLARE_TLV_DB_SCALE(adc4_pga_gain_tlv, 0, 100, 0);
-
-static const DECLARE_TLV_DB_SCALE(ch1_digital_vol_tlv, -9750, 50, 1);
-static const DECLARE_TLV_DB_SCALE(ch2_digital_vol_tlv, -9750, 50, 1);
-static const DECLARE_TLV_DB_SCALE(ch3_digital_vol_tlv, -9750, 50, 1);
-static const DECLARE_TLV_DB_SCALE(ch4_digital_vol_tlv, -9750, 50, 1);
-
-static const DECLARE_TLV_DB_SCALE(digital_mix_vol_tlv, -600,600,0);
-
-static const DECLARE_TLV_DB_SCALE(channel_enable_tlv, -1500, 100, 0);
-
-/* Analog ADC */
-static const char *analog_adc_mux_text[] = {
-	"Analog ADC1",
-	"Analog ADC2",
-	"Analog ADC3",
-	"Analog ADC4",
-};
-
-/* Channel Mapping */
-static const char *channel_map_mux_text[] = {
-	"1st adc sample",
-	"2st adc sample",
-	"3st adc sample",
-	"4st adc sample",
-};
-
-/*Tx source select channel*/
-static const char *channels_src_mux_text[] = {
-	"1 channels ",
-	"2 channels ",
-	"3 channels ",
-	"4 channels ",
-	"5 channels ",
-	"6 channels ",
-	"7 channels ",
-	"8 channels ",
-	"9 channels ",
-	"10 channels ",
-	"11 channels ",
-	"12 channels ",
-	"13 channels ",
-	"14 channels ",
-	"15 channels ",
-	"16 channels ",
-};
-
-static const  unsigned int ac108_channel_enable_values[] = {
-	0x00,
-	0x01,
-	0x03,
-	0x07,
-	0x0f,
-	0x1f,
-	0x3f,
-	0x7f,
-	0xff,
-};
-
-static const char *const ac108_channel_low_enable_texts[] = {
-	"disable all",
-	"1-1 channels ",
-	"1-2 channels ",
-	"1-3 channels ",
-	"1-4 channels ",
-	"1-5 channels ",
-	"1-6 channels ",
-	"1-7 channels ",
-	"1-8 channels ",
-};
-static const char *const ac108_channel_high_enable_texts[] = {
-	"disable all",
-	"8-9 channels ",
-	"8-10 channels ",
-	"8-11 channels ",
-	"8-12 channels ",
-	"8-13 channels ",
-	"8-14 channels ",
-	"8-15 channels ",
-	"8-16 channels ",
-};
-
-static const char *const ac108_data_source_texts[] = {
-	"ADC1 data",
-	"ADC2 data",
-	"ADC3 data",
-	"ADC4 data",
-	"disable all",
-};
-static const  unsigned int ac108_data_source_values[] = {
-	0x01,
-	0x02,
-	0x04,
-	0x08,
-	0x00,
-};
-
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_tx1_channel_low_enum,
-								  I2S_TX1_CTRL2, 0, 0xff,
-								  ac108_channel_low_enable_texts,
-								  ac108_channel_enable_values);
-
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_tx1_channel_high_enum,
-								  I2S_TX1_CTRL3, 0, 0xff,
-								  ac108_channel_high_enable_texts,
-								  ac108_channel_enable_values);
-
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_tx2_channel_low_enum,
-								  I2S_TX2_CTRL2, 0, 0xff,
-								  ac108_channel_low_enable_texts,
-								  ac108_channel_enable_values);
-
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_tx2_channel_high_enum,
-								  I2S_TX2_CTRL3, 0, 0xff,
-								  ac108_channel_high_enable_texts,
-								  ac108_channel_enable_values);
-
-/*0x76: ADC1 Digital Mixer Source Control Register*/
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc1_data_src_enum,
-								  ADC1_DMIX_SRC, 0, 0x0f,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc1_data_gc_enum,
-								  ADC1_DMIX_SRC, ADC1_ADC1_DMXL_GC, 0xf0,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-/*0x77: ADC2 Digital Mixer Source Control Register*/
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc2_data_src_enum,
-								  ADC2_DMIX_SRC, 0, 0x0f,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc2_data_gc_enum,
-								  ADC2_DMIX_SRC, ADC2_ADC1_DMXL_GC, 0xf0,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-/*0x78: ADC3 Digital Mixer Source Control Register*/
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc3_data_src_enum,
-								  ADC3_DMIX_SRC, 0, 0x0f,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc3_data_gc_enum,
-								  ADC3_DMIX_SRC, ADC3_ADC1_DMXL_GC, 0xf0,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-/*0x79: ADC4 Digital Mixer Source Control Register*/
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc4_data_src_enum,
-								  ADC4_DMIX_SRC, 0, 0x0f,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-static SOC_VALUE_ENUM_SINGLE_DECL(ac108_adc4_data_gc_enum,
-								  ADC4_DMIX_SRC, ADC4_ADC1_DMXL_GC, 0xf0,
-								  ac108_data_source_texts,
-								  ac108_data_source_values);
-
-static const struct soc_enum ac108_enum[] = {
-	/*0x38:TX1 Channel (slot) number Select for each output*/
-	SOC_ENUM_SINGLE(I2S_TX1_CTRL1, TX1_CHSEL, 16, channels_src_mux_text),
-	/*0x40:TX1 Channel (slot) number Select for each output*/
-	SOC_ENUM_SINGLE(I2S_TX2_CTRL1, TX2_CHSEL, 16, channels_src_mux_text),
-	/*0x3c:  TX1 Channel Mapping Control 1*/
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH1_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH2_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH3_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH4_MAP, 4, channel_map_mux_text),
-
-	/*0x3d:  TX1 Channel Mapping Control 2*/
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL2, TX1_CH5_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL2, TX1_CH6_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL2, TX1_CH7_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL2, TX1_CH8_MAP, 4, channel_map_mux_text),
-
-	/*0x3e:  TX1 Channel Mapping Control 3*/
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL3, TX1_CH9_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL3, TX1_CH10_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL3, TX1_CH11_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL3, TX1_CH12_MAP, 4, channel_map_mux_text),
-
-	/*0x3f:  TX1 Channel Mapping Control 4*/
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL4, TX1_CH13_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL4, TX1_CH14_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL4, TX1_CH15_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL4, TX1_CH16_MAP, 4, channel_map_mux_text),
-
-	/*0x44:  TX2 Channel Mapping Control 1*/
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL1, TX2_CH1_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL1, TX2_CH2_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL1, TX2_CH3_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL1, TX2_CH4_MAP, 4, channel_map_mux_text),
-
-	/*0x45:  TX2 Channel Mapping Control 2*/
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL2, TX2_CH5_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL2, TX2_CH6_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL2, TX2_CH7_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL2, TX2_CH8_MAP, 4, channel_map_mux_text),
-
-	/*0x46:  TX2 Channel Mapping Control 3*/
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL3, TX2_CH9_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL3, TX2_CH10_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL3, TX2_CH11_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL3, TX2_CH12_MAP, 4, channel_map_mux_text),
-
-	/*0x47:  TX2 Channel Mapping Control 4*/
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL4, TX2_CH13_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL4, TX2_CH14_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL4, TX2_CH15_MAP, 4, channel_map_mux_text),
-	SOC_ENUM_SINGLE(I2S_TX2_CHMP_CTRL4, TX2_CH16_MAP, 4, channel_map_mux_text),
-
-	/*0x63: ADC Digital Source Select Register*/
-	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC4_SRS, 4, analog_adc_mux_text),
-	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC3_SRS, 4, analog_adc_mux_text),
-	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC2_SRS, 4, analog_adc_mux_text),
-	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC1_SRS, 4, analog_adc_mux_text),
-
-};
-
-
-static const struct snd_kcontrol_new ac108_snd_controls[] = {
-
-	SOC_SINGLE("OUT1 Mute", I2S_FMT_CTRL3, 3, 1, 0),
-	SOC_SINGLE("OUT2 Mute", I2S_FMT_CTRL3, 4, 1, 0),
-#if 0
-	/*0x39:TX1 Channel1 ~Channel8 (slot) enable*/
-	SOC_ENUM("TX1 Channel1~8 enable", ac108_tx1_channel_low_enum),
-	/*0x3A:TX1 Channel1 ~Channel8 (slot) enable*/
-	SOC_ENUM("TX1 Channel9~16 enable", ac108_tx1_channel_high_enum),
-	/*0x41:TX2 Channel1 ~Channel8 (slot) enable*/
-	SOC_ENUM("TX2 Channel1~8 enable", ac108_tx2_channel_low_enum),
-	/*0x42:TX2 Channel1 ~Channel8 (slot) enable*/
-	SOC_ENUM("TX2 Channel9~16 enable", ac108_tx2_channel_high_enum),
-#endif
-
-	/*0x96-0x9F: use the default value*/
-#if 0
-	SOC_ENUM("Tx1 Channels", ac108_enum[0]),
-	SOC_ENUM("Tx2 Channels", ac108_enum[1]),
-	SOC_ENUM("Tx1 Channels 1 MAP", ac108_enum[2]),
-	SOC_ENUM("Tx1 Channels 2 MAP", ac108_enum[3]),
-	SOC_ENUM("Tx1 Channels 3 MAP", ac108_enum[4]),
-	SOC_ENUM("Tx1 Channels 4 MAP", ac108_enum[5]),
-	SOC_ENUM("Tx1 Channels 5 MAP", ac108_enum[6]),
-	SOC_ENUM("Tx1 Channels 6 MAP", ac108_enum[7]),
-	SOC_ENUM("Tx1 Channels 7 MAP", ac108_enum[8]),
-	SOC_ENUM("Tx1 Channels 8 MAP", ac108_enum[9]),
-	SOC_ENUM("Tx1 Channels 9 MAP", ac108_enum[10]),
-	SOC_ENUM("Tx1 Channels 10 MAP", ac108_enum[11]),
-	SOC_ENUM("Tx1 Channels 11 MAP", ac108_enum[12]),
-	SOC_ENUM("Tx1 Channels 12 MAP", ac108_enum[13]),
-	SOC_ENUM("Tx1 Channels 13 MAP", ac108_enum[14]),
-	SOC_ENUM("Tx1 Channels 14 MAP", ac108_enum[15]),
-	SOC_ENUM("Tx1 Channels 15 MAP", ac108_enum[16]),
-	SOC_ENUM("Tx1 Channels 16 MAP", ac108_enum[17]),
-
-	SOC_ENUM("Tx2 Channels 1 MAP", ac108_enum[18]),
-	SOC_ENUM("Tx2 Channels 2 MAP", ac108_enum[19]),
-	SOC_ENUM("Tx2 Channels 3 MAP", ac108_enum[20]),
-	SOC_ENUM("Tx2 Channels 4 MAP", ac108_enum[21]),
-	SOC_ENUM("Tx2 Channels 5 MAP", ac108_enum[22]),
-	SOC_ENUM("Tx2 Channels 6 MAP", ac108_enum[23]),
-	SOC_ENUM("Tx2 Channels 7 MAP", ac108_enum[24]),
-	SOC_ENUM("Tx2 Channels 8 MAP", ac108_enum[25]),
-	SOC_ENUM("Tx2 Channels 9 MAP", ac108_enum[26]),
-	SOC_ENUM("Tx2 Channels 10 MAP", ac108_enum[27]),
-	SOC_ENUM("Tx2 Channels 11 MAP", ac108_enum[28]),
-	SOC_ENUM("Tx2 Channels 12 MAP", ac108_enum[29]),
-	SOC_ENUM("Tx2 Channels 13 MAP", ac108_enum[30]),
-	SOC_ENUM("Tx2 Channels 14 MAP", ac108_enum[31]),
-	SOC_ENUM("Tx2 Channels 15 MAP", ac108_enum[32]),
-	SOC_ENUM("Tx2 Channels 16 MAP", ac108_enum[33]),
-#endif
-
-	SOC_ENUM("ADC4 Source", ac108_enum[34]),
-	SOC_ENUM("ADC3 Source", ac108_enum[35]),
-	SOC_ENUM("ADC2 Source", ac108_enum[36]),
-	SOC_ENUM("ADC1 Source", ac108_enum[37]),
-
-	SOC_ENUM("ADC1 Digital Mixer gc", ac108_adc1_data_gc_enum),
-	SOC_ENUM("ADC1 Digital Mixer src", ac108_adc1_data_src_enum),
-
-	SOC_ENUM("ADC2 Digital Mixer gc", ac108_adc2_data_gc_enum),
-	SOC_ENUM("ADC2 Digital Mixer src", ac108_adc2_data_src_enum),
-
-	SOC_ENUM("ADC3 Digital Mixer gc", ac108_adc3_data_gc_enum),
-	SOC_ENUM("ADC3 Digital Mixer src", ac108_adc3_data_src_enum),
-
-	SOC_ENUM("ADC4 Digital Mixer gc", ac108_adc4_data_gc_enum),
-	SOC_ENUM("ADC4 Digital Mixer src", ac108_adc4_data_src_enum),
-};
-
-
-static const struct snd_soc_dapm_widget ac108_dapm_widgets[] = {
-	//input widgets
-	SND_SOC_DAPM_INPUT("MIC1P"),
-	SND_SOC_DAPM_INPUT("MIC1N"),
-
-	SND_SOC_DAPM_INPUT("MIC2P"),
-	SND_SOC_DAPM_INPUT("MIC2N"),
-
-	SND_SOC_DAPM_INPUT("MIC3P"),
-	SND_SOC_DAPM_INPUT("MIC3N"),
-
-	SND_SOC_DAPM_INPUT("MIC4P"),
-	SND_SOC_DAPM_INPUT("MIC4N"),
-
-	SND_SOC_DAPM_INPUT("DMIC1"),
-	SND_SOC_DAPM_INPUT("DMIC2"),
-
-	/*0xa0: ADC1 Analog Control 1 Register*/
-	/*0xa1-0xa6:use the defualt value*/
-	SND_SOC_DAPM_AIF_IN("Channel 1 AAF", "Capture", 0, ANA_ADC1_CTRL1, ADC1_DSM_ENABLE, 1),
-	SND_SOC_DAPM_SUPPLY("Channel 1 EN", ANA_ADC1_CTRL1, ADC1_PGA_ENABLE, 1, NULL, 0),
-	SND_SOC_DAPM_MICBIAS("MIC1BIAS", ANA_ADC1_CTRL1, ADC1_MICBIAS_EN, 1),
-
-	/*0xa7: ADC2 Analog Control 1 Register*/
-	/*0xa8-0xad:use the defualt value*/
-	SND_SOC_DAPM_AIF_IN("Channel 2 AAF", "Capture", 0, ANA_ADC2_CTRL1, ADC2_DSM_ENABLE, 1),
-	SND_SOC_DAPM_SUPPLY("Channel 2 EN", ANA_ADC2_CTRL1, ADC2_PGA_ENABLE, 1, NULL, 0),
-	SND_SOC_DAPM_MICBIAS("MIC2BIAS", ANA_ADC2_CTRL1, ADC2_MICBIAS_EN, 1),
-
-	/*0xae: ADC3 Analog Control 1 Register*/
-	/*0xaf-0xb4:use the defualt value*/
-	SND_SOC_DAPM_AIF_IN("Channel 3 AAF", "Capture", 0, ANA_ADC3_CTRL1, ADC3_DSM_ENABLE, 1),
-	SND_SOC_DAPM_SUPPLY("Channel 3 EN", ANA_ADC3_CTRL1, ADC3_PGA_ENABLE, 1, NULL, 0),
-	SND_SOC_DAPM_MICBIAS("MIC3BIAS", ANA_ADC3_CTRL1, ADC3_MICBIAS_EN, 1),
-
-	/*0xb5: ADC4 Analog Control 1 Register*/
-	/*0xb6-0xbb:use the defualt value*/
-	SND_SOC_DAPM_AIF_IN("Channel 4 AAF", "Capture", 0, ANA_ADC4_CTRL1, ADC4_DSM_ENABLE, 1),
-	SND_SOC_DAPM_SUPPLY("Channel 4 EN", ANA_ADC4_CTRL1, ADC4_PGA_ENABLE, 1, NULL, 0),
-	SND_SOC_DAPM_MICBIAS("MIC4BIAS", ANA_ADC4_CTRL1, ADC4_MICBIAS_EN, 1),
-
-
-	/*0x61: ADC Digital Part Enable Register*/
-	SND_SOC_DAPM_SUPPLY("ADC EN", ADC_DIG_EN, 4,  1, NULL, 0),
-	SND_SOC_DAPM_ADC("ADC1", "Capture", ADC_DIG_EN, 0,  1),
-	SND_SOC_DAPM_ADC("ADC2", "Capture", ADC_DIG_EN, 1,  1),
-	SND_SOC_DAPM_ADC("ADC3", "Capture", ADC_DIG_EN, 2,  1),
-	SND_SOC_DAPM_ADC("ADC4", "Capture", ADC_DIG_EN, 3,  1),
-
-	SND_SOC_DAPM_SUPPLY("ADC1 CLK", ANA_ADC4_CTRL7, ADC1_CLK_GATING, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("ADC2 CLK", ANA_ADC4_CTRL7, ADC2_CLK_GATING, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("ADC3 CLK", ANA_ADC4_CTRL7, ADC3_CLK_GATING, 1, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("ADC4 CLK", ANA_ADC4_CTRL7, ADC4_CLK_GATING, 1, NULL, 0),
-
-	SND_SOC_DAPM_SUPPLY("DSM EN", ANA_ADC4_CTRL6, DSM_DEMOFF, 1, NULL, 0),
-
-	/*0x62:Digital MIC Enable Register*/
-	SND_SOC_DAPM_MICBIAS("DMIC1 enable", DMIC_EN, 0, 0),
-	SND_SOC_DAPM_MICBIAS("DMIC2 enable", DMIC_EN, 1, 0),
-
-	/**/
-};
-
-static const struct snd_soc_dapm_route ac108_dapm_routes[] = {
-
-	{ "ADC1", NULL, "Channel 1 AAF" },
-	{ "ADC2", NULL, "Channel 2 AAF" },
-	{ "ADC3", NULL, "Channel 3 AAF" },
-	{ "ADC4", NULL, "Channel 4 AAF" },
-
-	{ "Channel 1 AAF", NULL, "MIC1BIAS" },
-	{ "Channel 2 AAF", NULL, "MIC2BIAS" },
-	{ "Channel 3 AAF", NULL, "MIC3BIAS" },
-	{ "Channel 4 AAF", NULL, "MIC4BIAS" },
-
-	{ "MIC1BIAS", NULL, "ADC1 CLK" },
-	{ "MIC2BIAS", NULL, "ADC2 CLK" },
-	{ "MIC3BIAS", NULL, "ADC3 CLK" },
-	{ "MIC4BIAS", NULL, "ADC4 CLK" },
-
-
-	{ "ADC1 CLK", NULL, "DSM EN" },
-	{ "ADC2 CLK", NULL, "DSM EN" },
-	{ "ADC3 CLK", NULL, "DSM EN" },
-	{ "ADC4 CLK", NULL, "DSM EN" },
-
-
-	{ "DSM EN", NULL, "ADC EN" },
-
-	{ "Channel 1 EN", NULL, "DSM EN" },
-	{ "Channel 2 EN", NULL, "DSM EN" },
-	{ "Channel 3 EN", NULL, "DSM EN" },
-	{ "Channel 4 EN", NULL, "DSM EN" },
-
-
-	{ "MIC1P", NULL, "Channel 1 EN" },
-	{ "MIC1N", NULL, "Channel 1 EN" },
-
-	{ "MIC2P", NULL, "Channel 2 EN" },
-	{ "MIC2N", NULL, "Channel 2 EN" },
-
-	{ "MIC3P", NULL, "Channel 3 EN" },
-	{ "MIC3N", NULL, "Channel 3 EN" },
-
-	{ "MIC4P", NULL, "Channel 4 EN" },
-	{ "MIC4N", NULL, "Channel 4 EN" },
-
-};
-
-
-static int ac108_read(u8 reg, u8 *rt_value, struct i2c_client *client) {
-	int ret;
-	u8 read_cmd[3] = { reg, 0, 0 };
-	u8 cmd_len = 1;
-
-	ret = i2c_master_send(client, read_cmd, cmd_len);
-	if (ret != cmd_len) {
-		pr_err("ac108_read error1\n");
-		return -1;
-	}
-	ret = i2c_master_recv(client, rt_value, 1);
-	if (ret != 1) {
-		pr_err("ac108_read error2, ret = %d.\n", ret);
-		return -1;
-	}
-
-	return 0;
-}
-
-static int ac108_write(u8 reg, unsigned char val, struct i2c_client *client) {
-	int ret = 0;
-	u8 write_cmd[2] = { reg, val };
-
-	ret = i2c_master_send(client, write_cmd, 2);
-	if (ret != 2) {
-		pr_err("ac108_write error->[REG-0x%02x,val-0x%02x]\n", reg, val);
-		return -1;
-	}
-	return 0;
-}
-
-
-static int ac108_update_bits(u8 reg, u8 mask, u8 val, struct i2c_client *client) {
-	u8 val_old, val_new;
-
-	ac108_read(reg, &val_old, client);
-	val_new = (val_old & ~mask) | (val & mask);
-	if (val_new != val_old) {
-		ac108_write(reg, val_new, client);
-	}
-
-	return 0;
-}
-
-/**
- * snd_ac108_get_volsw - single mixer get callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to get the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_ac108_get_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol){
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	int max = mc->max;
-	int min = mc->min;
-	int chip = mc->autodisable;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	u8 val;
-	int ret;
-
-	ret = ac108_read(reg, &val, ac108_global->i2c[chip]);
-
-	if (ret < 0)
-		return ret;
-
-	val = (val >> shift) & mask;
-
-	ucontrol->value.integer.value[0] = val - min;
-	if (invert)
-		ucontrol->value.integer.value[0] =
-			max - ucontrol->value.integer.value[0];
-
-	return 0;
-}
-
-/**
- * snd_ac108_put_volsw - single mixer put callback
- * @kcontrol: mixer control
- * @ucontrol: control element information
- *
- * Callback to set the value of a single mixer control, or a double mixer
- * control that spans 2 registers.
- *
- * Returns 0 for success.
- */
-int snd_ac108_put_volsw(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol){
-	struct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	int max = mc->max;
-	int min = mc->min;
-	unsigned int sign_bit = mc->sign_bit;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
-	int err;
-	unsigned int val, val_mask;
-	int chip = mc->autodisable;
-
-	if (sign_bit)
-		mask = BIT(sign_bit + 1) - 1;
-
-	val = ((ucontrol->value.integer.value[0] + min) & mask);
-	if (invert)
-		val = max - val;
-	val_mask = mask << shift;
-	val = val << shift;
-
-	err = ac108_update_bits(reg, val_mask, val, ac108_global->i2c[chip]);
-	if (err < 0)
-		return err;
-
-
-	return err;
-}
-#define SOC_AC108_SINGLE_TLV(xname, reg, shift, max, invert, chip, tlv_array) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
-		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
-	.tlv.p = (tlv_array), \
-	.info = snd_soc_info_volsw, .get = snd_ac108_get_volsw,\
-	.put = snd_ac108_put_volsw, \
-	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, chip) }
-
-static const struct snd_kcontrol_new ac108_volume_snd_controls[] = {
-	/*0x70: ADC1 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH1 volume", ADC1_DVOL_CTRL, 0, 0xff, 0, 0, ch1_digital_vol_tlv),
-	/*0x71: ADC2 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH2 volume", ADC2_DVOL_CTRL, 0, 0xff, 0, 0, ch2_digital_vol_tlv),
-	/*0x72: ADC3 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH3 volume", ADC3_DVOL_CTRL, 0, 0xff, 0, 0, ch3_digital_vol_tlv),
-	/*0x73: ADC4 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH4 volume", ADC4_DVOL_CTRL, 0, 0xff, 0, 0, ch4_digital_vol_tlv),
-
-	/*0x90: Analog PGA1 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC1 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, 0, adc1_pga_gain_tlv),
-	/*0x91: Analog PGA2 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC2 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, 0, adc2_pga_gain_tlv),
-	/*0x92: Analog PGA3 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC3 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, 0, adc3_pga_gain_tlv),
-	/*0x93: Analog PGA4 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC4 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, 0, adc4_pga_gain_tlv),
-
-	/*0x70: ADC1 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH5 volume", ADC1_DVOL_CTRL, 0, 0xff, 0, 1, ch1_digital_vol_tlv),
-	/*0x71: ADC2 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH6 volume", ADC2_DVOL_CTRL, 0, 0xff, 0, 1, ch2_digital_vol_tlv),
-	/*0x72: ADC3 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH7 volume", ADC3_DVOL_CTRL, 0, 0xff, 0, 1, ch3_digital_vol_tlv),
-	/*0x73: ADC4 Digital Channel Volume Control Register*/
-	SOC_AC108_SINGLE_TLV("CH8 volume", ADC4_DVOL_CTRL, 0, 0xff, 0, 1, ch4_digital_vol_tlv),
-
-	/*0x90: Analog PGA1 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC5 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, 1, adc1_pga_gain_tlv),
-	/*0x91: Analog PGA2 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC6 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, 1, adc2_pga_gain_tlv),
-	/*0x92: Analog PGA3 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC7 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, 1, adc3_pga_gain_tlv),
-	/*0x93: Analog PGA4 Control Register*/
-	SOC_AC108_SINGLE_TLV("ADC8 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, 1, adc4_pga_gain_tlv),
-};
-
-
-static int ac108_multi_chips_read(u8 reg, u8 *rt_value, struct ac108_priv *ac108) {
-	u8 i;
-	for (i = 0; i < ac108->codec_index; i++) {
-		ac108_read(reg, rt_value++, ac108->i2c[i]);
-	}
-
-	return 0;
-}
-
-
-static int ac108_multi_chips_write(u8 reg, u8 val, struct ac108_priv *ac108) {
-	u8 i;
-	for (i = 0; i < ac108->codec_index; i++) {
-		ac108_write(reg, val, ac108->i2c[i]);
-	}
-	return 0;
-}
-
-static int ac108_multi_chips_update_bits(u8 reg, u8 mask, u8 val, struct ac108_priv *ac108) {
-	u8 i;
-	for (i = 0; i < ac108->codec_index; i++) {
-		ac108_update_bits(reg, mask, val, ac108->i2c[i]);
-	}
-	return 0;
-}
-
-static unsigned int ac108_codec_read(struct snd_soc_codec *codec, unsigned int reg) {
-	unsigned char val_r;
-	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
-	/*read one chip is fine*/
-	ac108_read(reg, &val_r, ac108->i2c[0]);
-	return val_r;
-}
-
-static int ac108_codec_write(struct snd_soc_codec *codec, unsigned int reg, unsigned int val) {
-	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
-	ac108_multi_chips_write(reg, val, ac108);
-	return 0;
-}
-
-/**
- * The Power management related registers are Reg01h~Reg09h
- * 0x01-0x05,0x08,use the default value
- * @author baozhu (17-6-21)
- * 
- * @param ac108 
- */
-static void ac108_configure_power(struct ac108_priv *ac108) {
-	/**
-	 * 0x06:Enable Analog LDO
-	 */
-	ac108_multi_chips_update_bits(PWR_CTRL6, 0x01 << LDO33ANA_ENABLE, 0x01 << LDO33ANA_ENABLE, ac108);
-	/**
-	 * 0x07: 
-	 * Control VREF output and micbias voltage ? 
-	 * REF faststart disable, enable Enable VREF (needed for Analog 
-	 * LDO and MICBIAS) 
-	 */
-	ac108_multi_chips_update_bits(PWR_CTRL7, 0x1f << VREF_SEL | 0x01 << VREF_FASTSTART_ENABLE | 0x01 << VREF_ENABLE,
-								  0x13 << VREF_SEL | 0x00 << VREF_FASTSTART_ENABLE | 0x01 << VREF_ENABLE, ac108);
-	/**
-	 * 0x09: 
-	 * Disable fast-start circuit on VREFP 
-	 * VREFP_RESCTRL=00=1 MOhm 
-	 * IGEN_TRIM=100=+25% 
-	 * Enable VREFP (needed by all audio input channels) 
-	 */
-	ac108_multi_chips_update_bits(PWR_CTRL9, 0x01 << VREFP_FASTSTART_ENABLE | 0x03 << VREFP_RESCTRL |
-								  0x07 << IGEN_TRIM | 0x01 << VREFP_ENABLE,
-								  0x00 << VREFP_FASTSTART_ENABLE | 0x00 << VREFP_RESCTRL |
-								  0x04 << IGEN_TRIM | 0x01 << VREFP_ENABLE, ac108);
-}
-
-/**
- * The clock management related registers are Reg20h~Reg25h
- * The PLL management related registers are Reg10h~Reg18h.
- * @author baozhu (17-6-20)
- * 
- * @param ac108 
- * @param rate : sample rate
- * 
- * @return int : fail or success
- */
-static int ac108_configure_clocking(struct ac108_priv *ac108, unsigned int rate) {
-	unsigned int i = 0;
-	struct pll_div ac108_pll_div = { 0 };
-	if (ac108->clk_id == SYSCLK_SRC_PLL) {
-		/* FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] */
-		for (i = 0; i < ARRAY_SIZE(ac108_pll_div_list); i++) {
-			if (ac108_pll_div_list[i].freq_in == ac108->sysclk && ac108_pll_div_list[i].freq_out % rate == 0) {
-				ac108_pll_div = ac108_pll_div_list[i];
-				break;
-			}
-		}
-		/* 0x11,0x12,0x13,0x14: Config PLL DIV param M1/M2/N/K1/K2 */
-		ac108_multi_chips_update_bits(PLL_CTRL5, 0x1f << PLL_POSTDIV1 | 0x01 << PLL_POSTDIV2, ac108_pll_div.k1 << PLL_POSTDIV1 |
-									  ac108_pll_div.k2 << PLL_POSTDIV2, ac108);
-		ac108_multi_chips_update_bits(PLL_CTRL4, 0xff << PLL_LOOPDIV_LSB, (unsigned char)ac108_pll_div.n << PLL_LOOPDIV_LSB, ac108);
-		ac108_multi_chips_update_bits(PLL_CTRL3, 0x03 << PLL_LOOPDIV_MSB, (ac108_pll_div.n >> 8) << PLL_LOOPDIV_MSB, ac108);
-		ac108_multi_chips_update_bits(PLL_CTRL2, 0x1f << PLL_PREDIV1 | 0x01 << PLL_PREDIV2,
-									  ac108_pll_div.m1 << PLL_PREDIV1 | ac108_pll_div.m2 << PLL_PREDIV2, ac108);
-
-		/*0x18: PLL clk lock enable*/
-		ac108_multi_chips_update_bits(PLL_LOCK_CTRL, 0x1 << PLL_LOCK_EN, 0x1 << PLL_LOCK_EN, ac108);
-		/*0x10: PLL Common voltage Enable, PLL Enable,PLL loop divider factor detection enable*/
-		ac108_multi_chips_update_bits(PLL_CTRL1, 0x01 << PLL_EN | 0x01 << PLL_COM_EN | 0x01 << PLL_NDET,
-									  0x1 << PLL_EN | 0x1 << PLL_COM_EN |  0x01 << PLL_NDET, ac108);
-
-		/**
-		 * 0x20: enable pll,pll source from mclk, sysclk source from 
-		 * pll,enable sysclk 
-		 */
-		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x01 << PLLCLK_EN | 0x03 << PLLCLK_SRC | 0x01 << SYSCLK_SRC | 0x01 << SYSCLK_EN,
-									  0x01 << PLLCLK_EN | 0x00 << PLLCLK_SRC | 0x01 << SYSCLK_SRC | 0x01 << SYSCLK_EN, ac108);
-	}
-	if (ac108->clk_id == SYSCLK_SRC_MCLK) {
-		/**
-		 *0x20: sysclk source from  mclk,enable sysclk 
-		 */
-		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x01 << PLLCLK_EN | 0x01 << SYSCLK_SRC | 0x01 << SYSCLK_EN,
-									  0x00 << PLLCLK_EN | 0x00 << SYSCLK_SRC | 0x01 << SYSCLK_EN, ac108);
-	}
-	/*0x21: Module clock enable<I2S, ADC digital, MIC offset Calibration, ADC analog>*/
-	ac108_multi_chips_write(MOD_CLK_EN, 1 << I2S | 1 << ADC_DIGITAL | 1 << MIC_OFFSET_CALIBRATION | 1 << ADC_ANALOG, ac108);
-	/*0x22: Module reset de-asserted<I2S, ADC digital, MIC offset Calibration, ADC analog>*/
-	ac108_multi_chips_write(MOD_RST_CTRL, 1 << I2S | 1 << ADC_DIGITAL | 1 << MIC_OFFSET_CALIBRATION | 1 << ADC_ANALOG, ac108);
-	return 0;
-}
-
-static int ac108_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params, struct snd_soc_dai *dai) {
-	unsigned int i, channels, sample_resolution, rate;
-	struct snd_soc_codec *codec = dai->codec;
-	struct ac108_priv *ac108 = snd_soc_codec_get_drvdata(codec);
-	rate = 99;
-	dev_dbg(dai->dev, "%s\n", __FUNCTION__);
-
-	channels = params_channels(params);
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S8:
-		sample_resolution = 0;
-		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		sample_resolution = 2;
-		break;
-	case SNDRV_PCM_FORMAT_S20_3LE:
-		sample_resolution = 3;
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		sample_resolution = 4;
-		break;
-	case SNDRV_PCM_FORMAT_S32_LE:
-		sample_resolution = 6;
-		break;
-	default:
-		dev_err(codec->dev, "AC108 don't supported the sample resolution: %u\n", params_format(params));
-		return -EINVAL;
-	}
-
-	dev_dbg(dai->dev,"rate:%d \n", params_rate(params));
-	for (i = 0; i < ARRAY_SIZE(ac108_sample_rate); i++) {
-		if (ac108_sample_rate[i].real_val == params_rate(params)) {
-			rate = i;
-			break;
-		}
-	}
-	if (rate == 99) {
-		dev_err(codec->dev, "unsupported rate %d\n",
-			params_rate(params));
-		return -EINVAL;
-	}
-
-
-	dev_dbg(dai->dev, "rate: %d , channels: %d , sample_resolution: %d",
-			ac108_sample_rate[rate].real_val,
-			channels,
-			ac108_sample_resolution[sample_resolution].real_val);
-
-	/**
-	 * 0x33: 
-	 *  The 8-Low bit of LRCK period value. It is used to program
-	 *  the number of BCLKs per channel of sample frame. This value
-	 *  is interpreted as follow:
-	 *  The 8-Low bit of LRCK period value. It is used to program
-	 *  the number of BCLKs per channel of sample frame. This value
-	 *  is interpreted as follow: PCM mode: Number of BCLKs within
-	 *  (Left + Right) channel width I2S / Left-Justified /
-	 *  Right-Justified mode: Number of BCLKs within each individual
-	 *  channel width (Left or Right) N+1
-	 *  For example:
-	 *  n = 7: 8 BCLK width
-	 *  â€¦
-	 *  n = 1023: 1024 BCLKs width
-	 *  0X32[0:1]:
-	 *  The 2-High bit of LRCK period value. 
-	 */
-	if (ac108->i2s_mode != PCM_FORMAT) {
-		if (ac108->data_protocol) {
-			ac108_multi_chips_write(I2S_LRCK_CTRL2, ac108_sample_resolution[sample_resolution].real_val - 1, ac108);
-			/*encoding mode, the max LRCK period value < 32,so the 2-High bit is zero*/
-			ac108_multi_chips_update_bits(I2S_LRCK_CTRL1, 0x03 << 0, 0x00, ac108);
-		} else {
-			/*TDM mode or normal mode*/
-			/**
-			 * TODO: need test.
-			 */
-			ac108_multi_chips_write(I2S_LRCK_CTRL2, ac108_sample_resolution[sample_resolution].real_val - 1, ac108);
-			/*encoding mode, the max LRCK period value < 32,so the 2-High bit is zero*/
-			ac108_multi_chips_update_bits(I2S_LRCK_CTRL1, 0x03 << 0, 0x00, ac108);
-		}
-
-	} else {
-		/**
-		 * TODO: need test.
-		 */
-	}
-
-	/**
-	 * 0x35: 
-	 * TX Encoding mode will add  4bits to mark channel number 
-	 * TODO: need a chat to explain this 
-	 */
-	ac108_multi_chips_update_bits(I2S_FMT_CTRL2, 0x07 << SAMPLE_RESOLUTION | 0x07 << SLOT_WIDTH_SEL,
-								  ac108_sample_resolution[sample_resolution].reg_val << SAMPLE_RESOLUTION
-								  | ac108_sample_resolution[sample_resolution].reg_val << SLOT_WIDTH_SEL, ac108);
-
-	/**
-	 * 0x60: 
-	 * ADC Sample Rate synchronised with I2S1 clock zone 
-	 */
-	ac108_multi_chips_update_bits(ADC_SPRC, 0x0f << ADC_FS_I2S1, ac108_sample_rate[rate].reg_val << ADC_FS_I2S1, ac108);
-
-	ac108_configure_clocking(ac108, rate);
-	return 0;
-}
-
-static int ac108_set_sysclk(struct snd_soc_dai *dai, int clk_id, unsigned int freq, int dir) {
-
-	struct ac108_priv *ac108 = snd_soc_dai_get_drvdata(dai);
-
-	switch (clk_id) {
-	case SYSCLK_SRC_MCLK:
-		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_SRC, SYSCLK_SRC_MCLK << SYSCLK_SRC, ac108);
-		break;
-	case SYSCLK_SRC_PLL:
-		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1 << SYSCLK_SRC, SYSCLK_SRC_PLL << SYSCLK_SRC, ac108);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/**
- *  The i2s format management related registers are Reg
- *  30h~Reg36h
- *  33h,35h will be set in ac108_hw_params, It's BCLK width and
- *  Sample Resolution.
- * @author baozhu (17-6-20)
- * 
- * @param dai 
- * @param fmt 
- * 
- * @return int 
- */
-static int ac108_set_fmt(struct snd_soc_dai *dai, unsigned int fmt) {
-
-	unsigned char tx_offset, lrck_polarity, brck_polarity;
-	struct ac108_priv *ac108 = dev_get_drvdata(dai->dev);
-
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:    /*AC108 Master*/
-		dev_dbg(dai->dev, "AC108 set to work as Master\n");
-		/**
-		 * 0x30:chip is master mode ,BCLK & LRCK output
-		 */
-		ac108_multi_chips_update_bits(I2S_CTRL, 0x03 << LRCK_IOEN, 0x03 << LRCK_IOEN, ac108);
-		/* multi_chips: only one chip set as Master, and the others also need to set as Slave */
-		if (ac108->codec_index > 1) ac108_update_bits(I2S_CTRL, 0x3 << LRCK_IOEN, 0x0 << LRCK_IOEN, ac108->i2c[1]);
-
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:    /*AC108 Slave*/
-		dev_dbg(dai->dev, "AC108 set to work as Slave\n");
-		/**
-		 * 0x30:chip is slave mode, BCLK & LRCK input,enable SDO1_EN and 
-		 *  SDO2_EN, Transmitter Block Enable, Globe Enable
-		 */
-		ac108_multi_chips_update_bits(I2S_CTRL, 0x03 << LRCK_IOEN | 0x03 << SDO1_EN | 0x1 << TXEN | 0x1 << GEN,
-									  0x00 << LRCK_IOEN | 0x03 << SDO1_EN | 0x1 << TXEN | 0x1 << GEN, ac108);
-		break;
-	default:
-		pr_err("AC108 Master/Slave mode config error:%u\n\n", (fmt & SND_SOC_DAIFMT_MASTER_MASK) >> 12);
-		return -EINVAL;
-	}
-
-	/*AC108 config I2S/LJ/RJ/PCM format*/
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_I2S:
-		dev_dbg(dai->dev, "AC108 config I2S format\n");
-		ac108->i2s_mode = LEFT_JUSTIFIED_FORMAT;
-		tx_offset = 1;
-		break;
-	case SND_SOC_DAIFMT_RIGHT_J:
-		dev_dbg(dai->dev, "AC108 config RIGHT-JUSTIFIED format\n");
-		ac108->i2s_mode = RIGHT_JUSTIFIED_FORMAT;
-		tx_offset = 0;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		dev_dbg(dai->dev, "AC108 config LEFT-JUSTIFIED format\n");
-		ac108->i2s_mode = LEFT_JUSTIFIED_FORMAT;
-		tx_offset = 0;
-		break;
-	case SND_SOC_DAIFMT_DSP_A:
-		dev_dbg(dai->dev, "AC108 config PCM-A format\n");
-		ac108->i2s_mode = PCM_FORMAT;
-		tx_offset = 1;
-		break;
-	case SND_SOC_DAIFMT_DSP_B:
-		dev_dbg(dai->dev, "AC108 config PCM-B format\n");
-		ac108->i2s_mode = PCM_FORMAT;
-		tx_offset = 0;
-		break;
-	default:
-		ac108->i2s_mode = LEFT_JUSTIFIED_FORMAT;
-		tx_offset = 1;
-		return -EINVAL;
-		pr_err("AC108 I2S format config error:%u\n\n", fmt & SND_SOC_DAIFMT_FORMAT_MASK);
-	}
-	/*AC108 config BCLK&LRCK polarity*/
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		dev_dbg(dai->dev, "AC108 config BCLK&LRCK polarity: BCLK_normal,LRCK_normal\n");
-		brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
-		lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		dev_dbg(dai->dev, "AC108 config BCLK&LRCK polarity: BCLK_normal,LRCK_invert\n");
-		brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
-		lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		dev_dbg(dai->dev, "AC108 config BCLK&LRCK polarity: BCLK_invert,LRCK_normal\n");
-		brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
-		lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		dev_dbg(dai->dev, "AC108 config BCLK&LRCK polarity: BCLK_invert,LRCK_invert\n");
-		brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
-		lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
-		break;
-	default:
-		pr_err("AC108 config BCLK/LRCLK polarity error:%u\n\n", (fmt & SND_SOC_DAIFMT_INV_MASK) >> 8);
-		return -EINVAL;
-	}
-	ac108_configure_power(ac108);
-
-	/**
-	 *0x31: 0: normal mode, negative edge drive and positive edge sample
-			1: invert mode, positive edge drive and negative edge sample
-	 */
-	ac108_multi_chips_update_bits(I2S_BCLK_CTRL,  0x01 << BCLK_POLARITY, brck_polarity << BCLK_POLARITY, ac108);
-	/**
-	 * 0x32: same as 0x31
-	 */
-	ac108_multi_chips_update_bits(I2S_LRCK_CTRL1, 0x01 << LRCK_POLARITY, lrck_polarity << LRCK_POLARITY, ac108);
-	/**
-	 * 0x34:Encoding Mode Selection,Mode 
-	 * Selection,data is offset by 1 BCLKs to LRCK 
-	 * normal mode for the last half cycle of BCLK in the slot ?
-	 * turn to hi-z state (TDM) when not transferring slot ?
-	 */
-	ac108_multi_chips_update_bits(I2S_FMT_CTRL1, 0x01 << ENCD_SEL | 0x03 << MODE_SEL | 0x01 << TX2_OFFSET |
-								  0x01 << TX1_OFFSET | 0x01 << TX_SLOT_HIZ | 0x01 << TX_STATE,
-								  ac108->data_protocol << ENCD_SEL 	|
-								  ac108->i2s_mode << MODE_SEL 		|
-								  tx_offset << TX2_OFFSET 			|
-								  tx_offset << TX1_OFFSET 			|
-								  0x00 << TX_SLOT_HIZ 				|
-								  0x01 << TX_STATE, ac108);
-
-	/**
-	 * 0x60: 
-	 * MSB / LSB First Select: This driver only support MSB First 
-	 * Select . 
-	 * OUT2_MUTE,OUT1_MUTE shoule be set in widget. 
-	 * LRCK = 1 BCLK width 
-	 * Linear PCM 
-	 *  
-	 * TODO:pcm mode, bit[0:1] and bit[2] is special
-	 */
-	ac108_multi_chips_update_bits(I2S_FMT_CTRL3, 0x01 << TX_MLS | 0x03 << SEXT  | 0x01 << LRCK_WIDTH | 0x03 << TX_PDM,
-								  0x00 << TX_MLS | 0x03 << SEXT  | 0x00 << LRCK_WIDTH | 0x00 << TX_PDM, ac108);
-
-	/**???*/
-	ac108_multi_chips_write(HPF_EN,0x00,ac108);
-
-	return 0;
-}
-
-static const struct snd_soc_dai_ops ac108_dai_ops = {
-	/*DAI clocking configuration*/
-	.set_sysclk = ac108_set_sysclk,
-
-
-	/*ALSA PCM audio operations*/
-	.hw_params = ac108_hw_params,
-//	.trigger = ac108_trigger,
-//	.hw_free = ac108_hw_free,
-//
-//	/*DAI format configuration*/
-	.set_fmt = ac108_set_fmt,
-};
-
-
-static const struct regmap_config ac108_regmap_config = {
-	.reg_bits = 8,
-	.val_bits = 8,
-	.max_register = PRNG_CLK_CTRL,
-	.cache_type = REGCACHE_RBTREE,
-};
-static  struct snd_soc_dai_driver ac108_dai0 = {
-	.name = "ac108-codec0",
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = AC108_CHANNELS_MAX,
-		.rates = AC108_RATES,
-		.formats = AC108_FORMATS,
-	},
-	.ops = &ac108_dai_ops,
-};
-
-
-static  struct snd_soc_dai_driver ac108_dai1 = {
-	.name = "ac108-codec1",
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = AC108_CHANNELS_MAX,
-		.rates = AC108_RATES,
-		.formats = AC108_FORMATS,
-	},
-	.ops = &ac108_dai_ops,
-};
-
-static  struct snd_soc_dai_driver ac108_dai2 = {
-	.name = "ac108-codec2",
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = AC108_CHANNELS_MAX,
-		.rates = AC108_RATES,
-		.formats = AC108_FORMATS,
-	},
-	.ops = &ac108_dai_ops,
-};
-
-static  struct snd_soc_dai_driver ac108_dai3 = {
-	.name = "ac108-codec3",
-	.capture = {
-		.stream_name = "Capture",
-		.channels_min = 1,
-		.channels_max = AC108_CHANNELS_MAX,
-		.rates = AC108_RATES,
-		.formats = AC108_FORMATS,
-	},
-	.ops = &ac108_dai_ops,
-};
-
-static  struct snd_soc_dai_driver *ac108_dai[] = {
-	&ac108_dai0,
-
-	&ac108_dai1,
-
-	&ac108_dai2,
-
-	&ac108_dai3,
-};
-
-static int ac108_add_widgets(struct snd_soc_codec *codec) {
-	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
-
-	snd_soc_add_codec_controls(codec, ac108_snd_controls,
-							   ARRAY_SIZE(ac108_snd_controls));
-
-	snd_soc_add_codec_controls(codec, ac108_volume_snd_controls,
-						   ARRAY_SIZE(ac108_volume_snd_controls));
-
-	snd_soc_dapm_new_controls(dapm, ac108_dapm_widgets,
-							  ARRAY_SIZE(ac108_dapm_widgets));
-
-	snd_soc_dapm_add_routes(dapm, ac108_dapm_routes, ARRAY_SIZE(ac108_dapm_routes));
-
-	return 0;
-}
-static int ac108_probe(struct snd_soc_codec *codec) {
-
-	int ret;
-	dev_set_drvdata(codec->dev, ac108_global);
-	ac108_add_widgets(codec);
-
-	ac108_global->mclk = devm_clk_get(codec->dev, "mclk");
-	if (IS_ERR(ac108_global->mclk)) {
-		dev_err(codec->dev, "%s mclk is missing or invalid\n", __func__);
-		return PTR_ERR(ac108_global->mclk);
-	}
-	ret = clk_prepare_enable(ac108_global->mclk);
-	if (ret)
-		return ret;
-
-	ac108_global->sysclk = clk_get_rate(ac108_global->mclk);
-	ac108_global->clk_id = SYSCLK_SRC_PLL;
-
-	pr_info("ac108 mclk is %d\n", ac108_global->sysclk);
-	return 0;
-}
-
-
-static int ac108_set_bias_level(struct snd_soc_codec *codec,
-								enum snd_soc_bias_level level) {
-	struct ac108_priv *ac108 = snd_soc_codec_get_drvdata(codec);
-	dev_dbg(codec->dev, "AC108 level:%d\n", level);
-	switch (level) {
-	case SND_SOC_BIAS_ON:
-		ac108_multi_chips_update_bits(ANA_ADC1_CTRL1, 0x01 << ADC1_MICBIAS_EN,  0x01 << ADC1_MICBIAS_EN, ac108);
-		ac108_multi_chips_update_bits(ANA_ADC2_CTRL1, 0x01 << ADC2_MICBIAS_EN,  0x01 << ADC2_MICBIAS_EN, ac108);
-		ac108_multi_chips_update_bits(ANA_ADC3_CTRL1, 0x01 << ADC3_MICBIAS_EN,  0x01 << ADC3_MICBIAS_EN, ac108);
-		ac108_multi_chips_update_bits(ANA_ADC4_CTRL1, 0x01 << ADC4_MICBIAS_EN,  0x01 << ADC4_MICBIAS_EN, ac108);
-		break;
-	case SND_SOC_BIAS_PREPARE:
-		/* Put the MICBIASes into regulating mode */
-		break;
-
-	case SND_SOC_BIAS_STANDBY:
-
-		break;
-
-	case SND_SOC_BIAS_OFF:
-		ac108_multi_chips_update_bits(ANA_ADC1_CTRL1, 0x01 << ADC1_MICBIAS_EN,  0x00 << ADC1_MICBIAS_EN, ac108);
-		ac108_multi_chips_update_bits(ANA_ADC2_CTRL1, 0x01 << ADC2_MICBIAS_EN,  0x00 << ADC2_MICBIAS_EN, ac108);
-		ac108_multi_chips_update_bits(ANA_ADC3_CTRL1, 0x01 << ADC3_MICBIAS_EN,  0x00 << ADC3_MICBIAS_EN, ac108);
-		ac108_multi_chips_update_bits(ANA_ADC4_CTRL1, 0x01 << ADC4_MICBIAS_EN,  0x00 << ADC4_MICBIAS_EN, ac108);
-		break;
-	}
-
-	return 0;
-}
-
-
-static const struct snd_soc_codec_driver ac108_soc_codec_driver = {
-	.probe = ac108_probe,
-	.set_bias_level = ac108_set_bias_level,
-	.read = ac108_codec_read,
-	.write = ac108_codec_write,
-};
-
-
-static ssize_t ac108_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
-	int val = 0, flag = 0;
-	u8 i = 0, reg, num, value_w, value_r;
-
-	val = simple_strtol(buf, NULL, 16);
-	flag = (val >> 16) & 0xF;
-
-	if (flag) {
-		reg = (val >> 8) & 0xFF;
-		value_w = val & 0xFF;
-		ac108_multi_chips_write(reg, value_w, ac108_global);
-		printk("Write 0x%02x to REG:0x%02x\n", value_w, reg);
-	} else {
-		reg = (val >> 8) & 0xFF;
-		num = val & 0xff;
-		printk("\nRead: start REG:0x%02x,count:0x%02x\n", reg, num);
-
-		do {
-			value_r = 0;
-			ac108_multi_chips_read(reg, &value_r, ac108_global);
-			printk("REG[0x%02x]: 0x%02x;  ", reg, value_r);
-			reg++;
-			i++;
-			if ((i == num) || (i % 4 == 0))	printk("\n");
-		} while (i < num);
-	}
-
-	return count;
-}
-
-static ssize_t ac108_show(struct device *dev, struct device_attribute *attr, char *buf) {
-#if 1
-	printk("echo flag|reg|val > ac108\n");
-	printk("eg read star addres=0x06,count 0x10:echo 0610 >ac108\n");
-	printk("eg write value:0xfe to address:0x06 :echo 106fe > ac108\n");
-	return 0;
-#else
-	return snprintf(buf, PAGE_SIZE,
-					"echo flag|reg|val > ac108\n"
-					"eg read star addres=0x06,count 0x10:echo 0610 >ac108\n"
-					"eg write value:0xfe to address:0x06 :echo 106fe > ac108\n");
-#endif
-}
-
-static DEVICE_ATTR(ac108, 0644, ac108_show, ac108_store);
-
-static struct attribute *ac108_debug_attrs[] = {
-	&dev_attr_ac108.attr,
-	NULL,
-};
-
-static struct attribute_group ac108_debug_attr_group = {
-	.name   = "ac108_debug",
-	.attrs  = ac108_debug_attrs,
-};
-
-
-
-
-static int ac108_i2c_probe(struct i2c_client *i2c,
-						   const struct i2c_device_id *i2c_id) {
-	int ret = 0;
-	struct device_node *np = i2c->dev.of_node;
-	unsigned int val = 0;
-	int ii;
-
-	if (ac108_global == NULL) {
-		ac108_global = devm_kzalloc(&i2c->dev, sizeof(struct ac108_priv), GFP_KERNEL);
-		if (ac108_global == NULL) {
-			dev_err(&i2c->dev, "Unable to allocate ac108 private data\n");
-			return -ENOMEM;
-		}
-	}
-
-	if (!of_find_property(np, "init-data", &ac108_global->reg_length)){
-		pr_err(" error init-data not property!!!\n");
-		ac108_global->reg_length = 0;
-	}
-
-
-	ac108_global->reg_length = ac108_global->reg_length / sizeof(u8);
-
-	/* read max_num from DT property */
-	if (ac108_global->reg_length > 0) {
-	
-		ac108_global->init_regs = (unsigned char *)vmalloc(ac108_global->reg_length);
-		if (!ac108_global->init_regs){
-			dev_err(&i2c->dev,"<ac108->init_regs> error vmalloc failed!!!\n");
-			return -ENOMEM;
-		}
-
-		ret = of_property_read_u8_array(np,"init-data",ac108_global->init_regs,ac108_global->reg_length);
-		if (ret != 0){
-			dev_err(&i2c->dev," of_property_read_u8_array failed!!!\n");
-			return -EINVAL;
-		}
-	} else
-		pr_info("ac108 probe without init data\n");
-
-
-	ret = of_property_read_u32(np, "data-protocol", &val);
-	if (ret) {
-		pr_err("Please set data-protocol.\n");
-		return -EINVAL;
-	}
-	ac108_global->data_protocol = val;
-
-
-	pr_err(" i2c_id number :%d\n", (int)(i2c_id->driver_data));
-	pr_err(" ac108  codec_index :%d\n", ac108_global->codec_index);
-	pr_err(" ac108  I2S data protocol type :%d\n", ac108_global->data_protocol);
-
-	ac108_global->i2c[i2c_id->driver_data] = i2c;
-	ret = snd_soc_register_codec(&i2c->dev, &ac108_soc_codec_driver, ac108_dai[i2c_id->driver_data], 1);
-	if (ret < 0) {
-		dev_err(&i2c->dev, "Failed to register ac108 codec: %d\n", ret);
-	}
-	ac108_global->codec_index++;
-
-	/*Writing this register 0x12 resets all register to their default state.*/
-	ac108_write(CHIP_RST, CHIP_RST_VAL, i2c);
-
-	/*if ac108 has init data,write now*/
-	for (ii = 0; ii < ac108_global->reg_length-1;ii+=2) {
-		ac108_write(ac108_global->init_regs[ii],ac108_global->init_regs[ii+1],i2c);
-	}
-
-	ret = sysfs_create_group(&i2c->dev.kobj, &ac108_debug_attr_group);
-	if (ret) {
-		pr_err("failed to create attr group\n");
-	}
-
-	return ret;
-}
-
-static int ac108_i2c_remove(struct i2c_client *client) {
-	snd_soc_unregister_codec(&client->dev);
-	return 0;
-}
-
-static const struct i2c_device_id ac108_i2c_id[] = {
-	{ "ac108_0", 0 },
-	{ "ac108_1", 1 },
-	{ "ac108_2", 2 },
-	{ "ac108_3", 3 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, ac108_i2c_id);
-
-static const struct of_device_id ac108_of_match[] = {
-	{ .compatible = "x-power,ac108_0", },
-	{ .compatible = "x-power,ac108_1", },
-	{ .compatible = "x-power,ac108_2", },
-	{ .compatible = "x-power,ac108_3", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, ac108_of_match);
-
-static struct i2c_driver ac108_i2c_driver = {
-	.driver = {
-		.name = "ac108-codec",
-		.of_match_table = ac108_of_match,
-	},
-	.probe =    ac108_i2c_probe,
-	.remove =   ac108_i2c_remove,
-	.id_table = ac108_i2c_id,
-};
-
-module_i2c_driver(ac108_i2c_driver);
-
-MODULE_DESCRIPTION("ASoC AC108 driver");
-MODULE_AUTHOR("Baozhu Zuo<zuobaozhu@gmail.com>");
-MODULE_LICENSE("GPL");
-
+/*
+ * ac108.c  --  ac108 ALSA Soc Audio driver
+ *
+ * Version: 2.0
+ *
+ * Author: panjunwen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+#include <sound/tlv.h>
+#include <linux/regulator/consumer.h>
+#include <linux/io.h>
+
+#include "ac108.h"
+
+
+#define AC108_DEBUG_EN			0
+
+#if AC108_DEBUG_EN
+#define AC108_DEBUG(...)		pr_info(__VA_ARGS__)
+#else
+#define AC108_DEBUG(...)
+#endif
+
+
+//test config
+#define AC108_DAPM_TEST_EN		0
+#define AC108_CODEC_RW_TEST_EN	0
+#define AC108_ADC_PATTERN_SEL	ADC_PTN_NORMAL		//0:ADC normal,  1:0x5A5A5A,  2:0x123456,  3:0x000000,  4~7:I2S_RX_DATA,  other:reserved
+
+
+//AC108 config
+#define AC108_CHANNELS_MAX		8		//range[1, 16]
+#define AC108_SLOT_WIDTH		32		//16bit or 32bit slot width, other value will be reserved
+#define AC108_DMIC_EN			0		//0:ADC	 1:DMIC
+#define AC108_ENCODING_EN		0		//TX Encoding mode enable
+#define AC108_ENCODING_CH_NUMS 	8		//TX Encoding channel numbers, must be dual, range[1, 16]
+#define AC108_PGA_GAIN			ADC_PGA_GAIN_30dB	//0dB/-6dB, 3~30dB
+//#define AC108_LRCK_PERIOD		(AC108_SLOT_WIDTH*(AC108_ENCODING_EN ? 2 : AC108_CHANNELS_MAX))	//range[1, 1024], default PCM mode, I2S/LJ/RJ mode shall divide by 2
+#define AC108_LRCK_PERIOD		AC108_SLOT_WIDTH
+
+
+#define AC108_I2C_BUS_NUM 		1		//the I2C BUS number which AC108 mount on
+#define AC108_SDO2_EN			1		//AC108 SDO2/TX2 Enable (SDO1 has be enabled default)
+#define AC108_IDLE_RESET_EN		0		//reset AC108 when in idle time
+#define AC108_MATCH_DTS_EN		1		//AC108 match method select: 0: i2c_detect, 1:of_device_id
+
+#define AC108_REGULATOR_NAME	"voltage_enable"
+#define AC108_RATES 			(SNDRV_PCM_RATE_8000_96000 | SNDRV_PCM_RATE_KNOT)
+#define AC108_FORMATS			(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+
+static const DECLARE_TLV_DB_SCALE(adc_pga_gain_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(ch_digital_vol_tlv, -9750, 50, 1);
+
+struct i2c_client *i2c_clt[(AC108_CHANNELS_MAX+3)/4];
+int	regulator_en;
+
+struct voltage_supply {
+	struct regulator *vcc3v3;
+};
+
+struct ac108_priv {
+	struct i2c_client *i2c;
+	struct snd_soc_codec *codec;
+	struct voltage_supply vol_supply;
+};
+
+static const struct regmap_config ac108_regmap_config = {
+	.reg_bits = 8,	//Number of bits in a register address
+	.val_bits = 8,	//Number of bits in a register value
+};
+
+
+struct real_val_to_reg_val {
+	unsigned int real_val;
+	unsigned int reg_val;
+};
+
+struct pll_div {
+	u32 freq_in;
+	u32 freq_out;
+	u32 m1;
+	u32 m2;
+	u32 n;
+	u32 k1;
+	u32 k2;
+};
+
+
+
+static const struct real_val_to_reg_val ac108_sample_rate[] = {
+	{8000,  0},
+	{11025, 1},
+	{12000, 2},
+	{16000, 3},
+	{22050, 4},
+	{24000, 5},
+	{32000, 6},
+	{44100, 7},
+	{48000, 8},
+	{96000, 9},
+};
+
+static const struct real_val_to_reg_val ac108_sample_resolution[] = {
+	{8,  1},
+	{12, 2},
+	{16, 3},
+	{20, 4},
+	{24, 5},
+	{28, 6},
+	{32, 7},
+};
+
+static const struct real_val_to_reg_val ac108_bclk_div[] = {
+	{0,  0},
+	{1,  1},
+	{2,  2},
+	{4,  3},
+	{6,  4},
+	{8,  5},
+	{12, 6},
+	{16, 7},
+	{24, 8},
+	{32, 9},
+	{48, 10},
+	{64, 11},
+	{96, 12},
+	{128,13},
+	{176,14},
+	{192,15},
+};
+
+//FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] ;	M1[0,31],  M2[0,1],  N[0,1023],  K1[0,31],  K2[0,1]
+static const struct pll_div ac108_pll_div[] = {
+	{400000,   24576000, 0,  0, 614, 4, 1},
+	{512000,   24576000, 0,  0, 960, 9, 1},	//24576000/48
+	{768000,   24576000, 0,  0, 640, 9, 1},	//24576000/32
+	{800000,   24576000, 0,  0, 614, 9, 1},
+	{1024000,  24576000, 0,  0, 480, 9, 1},	//24576000/24
+	{1600000,  24576000, 0,  0, 307, 9, 1},
+	{2048000,  24576000, 0,  0, 240, 9, 1},	//24576000/12
+	{3072000,  24576000, 0,  0, 160, 9, 1},	//24576000/8
+	{4096000,  24576000, 2,  0, 360, 9, 1},	//24576000/6
+	{6000000,  24576000, 4,  0, 410, 9, 1},
+	{12000000, 24576000, 9,  0, 410, 9, 1},
+	{13000000, 24576000, 8,  0, 340, 9, 1},
+	{15360000, 24576000, 12, 0, 415, 9, 1},
+	{16000000, 24576000, 12, 0, 400, 9, 1},
+	{19200000, 24576000, 15, 0, 410, 9, 1},
+	{19680000, 24576000, 15, 0, 400, 9, 1},
+	{24000000, 24576000, 9,  0, 205, 9, 1},
+	
+	{400000,   22579200, 0,  0, 566, 4, 1},
+	{512000,   22579200, 0,  0, 880, 9, 1},
+	{768000,   22579200, 0,  0, 587, 9, 1},
+	{800000,   22579200, 0,  0, 567, 9, 1},
+	{1024000,  22579200, 0,  0, 440, 9, 1},
+	{1600000,  22579200, 1,  0, 567, 9, 1},
+	{2048000,  22579200, 0,  0, 220, 9, 1},
+	{3072000,  22579200, 0,  0, 148, 9, 1},
+	{4096000,  22579200, 2,  0, 330, 9, 1},
+	{6000000,  22579200, 2,  0, 227, 9, 1},
+	{12000000, 22579200, 8,  0, 340, 9, 1},
+	{13000000, 22579200, 9,  0, 350, 9, 1},
+	{15360000, 22579200, 10, 0, 325, 9, 1},
+	{16000000, 22579200, 11, 0, 340, 9, 1},
+	{19200000, 22579200, 13, 0, 330, 9, 1},
+	{19680000, 22579200, 14, 0, 345, 9, 1},
+	{24000000, 22579200, 16, 0, 320, 9, 1},
+
+	{12288000, 24576000, 9,  0, 400, 9, 1},	//24576000/2
+	{11289600, 22579200, 9,  0, 400, 9, 1},	//22579200/2
+
+	{24576000/1,   24576000, 9,  0, 200, 9, 1},	//24576000
+	{24576000/4,   24576000, 4,  0, 400, 9, 1},	//6144000
+	{24576000/16,  24576000, 0,  0, 320, 9, 1},	//1536000
+	{24576000/64,  24576000, 0,  0, 640, 4, 1},	//384000
+	{24576000/96,  24576000, 0,  0, 960, 4, 1},	//256000
+	{24576000/128, 24576000, 0,  0, 512, 1, 1},	//192000
+	{24576000/176, 24576000, 0,  0, 880, 4, 0},	//140000
+	{24576000/192, 24576000, 0,  0, 960, 4, 0},	//128000
+
+	{22579200/1,   22579200, 9,  0, 200, 9, 1},	//22579200
+	{22579200/4,   22579200, 4,  0, 400, 9, 1},	//5644800
+	{22579200/16,  22579200, 0,  0, 320, 9, 1},	//1411200
+	{22579200/64,  22579200, 0,  0, 640, 4, 1},	//352800
+	{22579200/96,  22579200, 0,  0, 960, 4, 1},	//235200
+	{22579200/128, 22579200, 0,  0, 512, 1, 1},	//176400
+	{22579200/176, 22579200, 0,  0, 880, 4, 0},	//128290
+	{22579200/192, 22579200, 0,  0, 960, 4, 0},	//117600
+
+	{22579200/6,   22579200, 2,  0, 360, 9, 1},	//3763200
+	{22579200/8,   22579200, 0,  0, 160, 9, 1}, //2822400
+	{22579200/12,  22579200, 0,  0, 240, 9, 1},	//1881600
+	{22579200/24,  22579200, 0,  0, 480, 9, 1}, //940800
+	{22579200/32,  22579200, 0,  0, 640, 9, 1}, //705600
+	{22579200/48,  22579200, 0,  0, 960, 9, 1}, //470400
+};
+
+
+static const DECLARE_TLV_DB_SCALE(adc1_pga_gain_tlv,0,100,0);
+static const DECLARE_TLV_DB_SCALE(adc2_pga_gain_tlv,0,100,0);
+static const DECLARE_TLV_DB_SCALE(adc3_pga_gain_tlv,0,100,0);
+static const DECLARE_TLV_DB_SCALE(adc4_pga_gain_tlv,0,100,0);
+
+static const DECLARE_TLV_DB_SCALE(ch1_digital_vol_tlv,-11925,75,0);
+static const DECLARE_TLV_DB_SCALE(ch2_digital_vol_tlv,-11925,75,0);
+static const DECLARE_TLV_DB_SCALE(ch3_digital_vol_tlv,-11925,75,0);
+static const DECLARE_TLV_DB_SCALE(ch4_digital_vol_tlv,-11925,75,0);
+
+static const DECLARE_TLV_DB_SCALE(channel1_ch1_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel1_ch2_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel1_ch3_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel1_ch4_dig_mix_vol_tlv,-600,600,0);
+
+static const DECLARE_TLV_DB_SCALE(channel2_ch1_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel2_ch2_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel2_ch3_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel2_ch4_dig_mix_vol_tlv,-600,600,0);
+
+static const DECLARE_TLV_DB_SCALE(channel3_ch1_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel3_ch2_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel3_ch3_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel3_ch4_dig_mix_vol_tlv,-600,600,0);
+
+static const DECLARE_TLV_DB_SCALE(channel4_ch1_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel4_ch2_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel4_ch3_dig_mix_vol_tlv,-600,600,0);
+static const DECLARE_TLV_DB_SCALE(channel4_ch4_dig_mix_vol_tlv,-600,600,0);
+
+//static const DECLARE_TLV_DB_SCALE(adc_pga_gain_tlv,0,100,0);
+//static const DECLARE_TLV_DB_SCALE(digital_vol_tlv,-11925,75,0);
+//static const DECLARE_TLV_DB_SCALE(digital_mix_vol_tlv,-600,600,0);
+
+
+/*************************************** General(volume) controls *******************************************/
+//ac108 common controls
+static const struct snd_kcontrol_new ac108_controls[] = {
+	SOC_SINGLE_TLV("ADC1 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, adc1_pga_gain_tlv),
+	SOC_SINGLE_TLV("ADC2 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, adc2_pga_gain_tlv),
+	SOC_SINGLE_TLV("ADC3 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, adc3_pga_gain_tlv),
+	SOC_SINGLE_TLV("ADC4 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, adc4_pga_gain_tlv),
+
+	SOC_SINGLE_TLV("CH1 digital volume", ADC1_DVOL_CTRL, 0, 0xff, 0, ch1_digital_vol_tlv),
+	SOC_SINGLE_TLV("CH2 digital volume", ADC2_DVOL_CTRL, 0, 0xff, 0, ch2_digital_vol_tlv),
+	SOC_SINGLE_TLV("CH3 digital volume", ADC3_DVOL_CTRL, 0, 0xff, 0, ch3_digital_vol_tlv),
+	SOC_SINGLE_TLV("CH4 digital volume", ADC4_DVOL_CTRL, 0, 0xff, 0, ch4_digital_vol_tlv),
+
+	SOC_SINGLE_TLV("CH1 ch1 mixer gain", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_GC, 1, 0, channel1_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH1 ch2 mixer gain", ADC1_DMIX_SRC, ADC1_ADC2_DMXL_GC, 1, 0, channel1_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH1 ch3 mixer gain", ADC1_DMIX_SRC, ADC1_ADC3_DMXL_GC, 1, 0, channel1_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH1 ch4 mixer gain", ADC1_DMIX_SRC, ADC1_ADC4_DMXL_GC, 1, 0, channel1_ch4_dig_mix_vol_tlv),
+
+	SOC_SINGLE_TLV("CH2 ch1 mixer gain", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_GC, 1, 0, channel2_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH2 ch2 mixer gain", ADC2_DMIX_SRC, ADC2_ADC2_DMXL_GC, 1, 0, channel2_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH2 ch3 mixer gain", ADC2_DMIX_SRC, ADC2_ADC3_DMXL_GC, 1, 0, channel2_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH2 ch4 mixer gain", ADC2_DMIX_SRC, ADC2_ADC4_DMXL_GC, 1, 0, channel2_ch4_dig_mix_vol_tlv),
+
+	SOC_SINGLE_TLV("CH3 ch1 mixer gain", ADC3_DMIX_SRC, ADC3_ADC1_DMXL_GC, 1, 0, channel3_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH3 ch2 mixer gain", ADC3_DMIX_SRC, ADC3_ADC2_DMXL_GC, 1, 0, channel3_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH3 ch3 mixer gain", ADC3_DMIX_SRC, ADC3_ADC3_DMXL_GC, 1, 0, channel3_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH3 ch4 mixer gain", ADC3_DMIX_SRC, ADC3_ADC4_DMXL_GC, 1, 0, channel3_ch4_dig_mix_vol_tlv),
+
+	SOC_SINGLE_TLV("CH4 ch1 mixer gain", ADC4_DMIX_SRC, ADC4_ADC1_DMXL_GC, 1, 0, channel4_ch1_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH4 ch2 mixer gain", ADC4_DMIX_SRC, ADC4_ADC2_DMXL_GC, 1, 0, channel4_ch2_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH4 ch3 mixer gain", ADC4_DMIX_SRC, ADC4_ADC3_DMXL_GC, 1, 0, channel4_ch3_dig_mix_vol_tlv),
+	SOC_SINGLE_TLV("CH4 ch4 mixer gain", ADC4_DMIX_SRC, ADC4_ADC4_DMXL_GC, 1, 0, channel4_ch4_dig_mix_vol_tlv),
+
+	//SOC_SINGLE_TLV("CH1 mixer gain", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_GC, 0x0f, 0, digital_mix_vol_tlv),
+	//SOC_SINGLE_TLV("CH2 mixer gain", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_GC, 0x0f, 0, digital_mix_vol_tlv),
+	//SOC_SINGLE_TLV("CH3 mixer gain", ADC3_DMIX_SRC, ADC3_ADC1_DMXL_GC, 0x0f, 0, digital_mix_vol_tlv),
+	//SOC_SINGLE_TLV("CH4 mixer gain", ADC4_DMIX_SRC, ADC4_ADC1_DMXL_GC, 0x0f, 0, digital_mix_vol_tlv),
+};
+
+
+/*************************************** DAPM controls *******************************************/
+//ADC12 DMIC1 Source Select Mux
+static const char *adc12_dmic1_src_mux_text[] = {
+	"ADC12 switch", "DMIC1 switch"
+};
+static const struct soc_enum adc12_dmic1_src_mux_enum =
+	SOC_ENUM_SINGLE(DMIC_EN, DMIC1_EN, 2, adc12_dmic1_src_mux_text);
+static const struct snd_kcontrol_new adc12_dmic1_src_mux =
+	SOC_DAPM_ENUM("ADC12 DMIC1 MUX", adc12_dmic1_src_mux_enum);
+
+//ADC34 DMIC2 Source Select Mux
+static const char *adc34_dmic2_src_mux_text[] = {
+	"ADC34 switch", "DMIC2 switch"
+};
+static const struct soc_enum adc34_dmic2_src_mux_enum =
+	SOC_ENUM_SINGLE(DMIC_EN, DMIC2_EN, 2, adc34_dmic2_src_mux_text);
+static const struct snd_kcontrol_new adc34_dmic2_src_mux =
+	SOC_DAPM_ENUM("ADC34 DMIC2 MUX", adc34_dmic2_src_mux_enum);
+
+//ADC1 Digital Source Select Mux
+static const char *adc1_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc1_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC1_SRS, 4, adc1_digital_src_mux_text);
+static const struct snd_kcontrol_new adc1_digital_src_mux =
+	SOC_DAPM_ENUM("ADC1 DIG MUX", adc1_digital_src_mux_enum);
+
+//ADC2 Digital Source Select Mux
+static const char *adc2_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc2_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC2_SRS, 4, adc2_digital_src_mux_text);
+static const struct snd_kcontrol_new adc2_digital_src_mux =
+	SOC_DAPM_ENUM("ADC2 DIG MUX", adc2_digital_src_mux_enum);
+
+//ADC3 Digital Source Select Mux
+static const char *adc3_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc3_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC3_SRS, 4, adc3_digital_src_mux_text);
+static const struct snd_kcontrol_new adc3_digital_src_mux =
+	SOC_DAPM_ENUM("ADC3 DIG MUX", adc3_digital_src_mux_enum);
+
+//ADC4 Digital Source Select Mux
+static const char *adc4_digital_src_mux_text[] = {
+	"ADC1 switch", "ADC2 switch", "ADC3 switch", "ADC4 switch"
+};
+static const struct soc_enum adc4_digital_src_mux_enum =
+	SOC_ENUM_SINGLE(ADC_DSR, DIG_ADC4_SRS, 4, adc4_digital_src_mux_text);
+static const struct snd_kcontrol_new adc4_digital_src_mux =
+	SOC_DAPM_ENUM("ADC4 DIG MUX", adc4_digital_src_mux_enum);
+
+//ADC1 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc1_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC1_DMIX_SRC, ADC1_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC1_DMIX_SRC, ADC1_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC1_DMIX_SRC, ADC1_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC1_DMIX_SRC, ADC1_ADC4_DMXL_SRC, 1, 0),
+};
+
+//ADC2 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc2_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC2_DMIX_SRC, ADC2_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC2_DMIX_SRC, ADC2_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC2_DMIX_SRC, ADC2_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC2_DMIX_SRC, ADC2_ADC4_DMXL_SRC, 1, 0),
+};
+
+//ADC3 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc3_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC3_DMIX_SRC, ADC3_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC3_DMIX_SRC, ADC3_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC3_DMIX_SRC, ADC3_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC3_DMIX_SRC, ADC3_ADC4_DMXL_SRC, 1, 0),
+};
+
+//ADC4 Digital Source Control Mixer
+static const struct snd_kcontrol_new adc4_digital_src_mixer[] = {
+	SOC_DAPM_SINGLE("ADC1 DAT switch", ADC4_DMIX_SRC, ADC4_ADC1_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC2 DAT switch", ADC4_DMIX_SRC, ADC4_ADC2_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC3 DAT switch", ADC4_DMIX_SRC, ADC4_ADC3_DMXL_SRC, 1, 0),
+	SOC_DAPM_SINGLE("ADC4 DAT switch", ADC4_DMIX_SRC, ADC4_ADC4_DMXL_SRC, 1, 0),
+};
+
+//I2S TX1 Ch1 Mapping Mux
+static const char *i2s_tx1_ch1_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch", "ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch1_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH1_MAP, 4, i2s_tx1_ch1_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch1_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH1 MUX", i2s_tx1_ch1_map_mux_enum);
+
+//I2S TX1 Ch2 Mapping Mux
+static const char *i2s_tx1_ch2_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch", "ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch2_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH2_MAP, 4, i2s_tx1_ch2_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch2_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH2 MUX", i2s_tx1_ch2_map_mux_enum);
+
+//I2S TX1 Ch3 Mapping Mux
+static const char *i2s_tx1_ch3_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch", "ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch3_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH3_MAP, 4, i2s_tx1_ch3_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch3_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH3 MUX", i2s_tx1_ch3_map_mux_enum);
+
+//I2S TX1 Ch4 Mapping Mux
+static const char *i2s_tx1_ch4_map_mux_text[] = {
+	"ADC1 Sample switch", "ADC2 Sample switch", "ADC3 Sample switch", "ADC4 Sample switch"
+};
+static const struct soc_enum i2s_tx1_ch4_map_mux_enum =
+	SOC_ENUM_SINGLE(I2S_TX1_CHMP_CTRL1, TX1_CH4_MAP, 4, i2s_tx1_ch4_map_mux_text);
+static const struct snd_kcontrol_new i2s_tx1_ch4_map_mux =
+	SOC_DAPM_ENUM("I2S TX1 CH4 MUX", i2s_tx1_ch4_map_mux_enum);
+
+
+/*************************************** DAPM widgets *******************************************/
+//ac108 dapm widgets
+static const struct snd_soc_dapm_widget ac108_dapm_widgets[] = {
+	//input widgets
+	SND_SOC_DAPM_INPUT("MIC1P"),
+	SND_SOC_DAPM_INPUT("MIC1N"),
+	
+	SND_SOC_DAPM_INPUT("MIC2P"),
+	SND_SOC_DAPM_INPUT("MIC2N"),
+	
+	SND_SOC_DAPM_INPUT("MIC3P"),
+	SND_SOC_DAPM_INPUT("MIC3N"),
+	
+	SND_SOC_DAPM_INPUT("MIC4P"),
+	SND_SOC_DAPM_INPUT("MIC4N"),
+
+	SND_SOC_DAPM_INPUT("DMIC1"),
+	SND_SOC_DAPM_INPUT("DMIC2"),
+
+
+	//MIC PGA
+	SND_SOC_DAPM_PGA("MIC1 PGA", ANA_ADC1_CTRL1, ADC1_PGA_ENABLE, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC2 PGA", ANA_ADC2_CTRL1, ADC2_PGA_ENABLE, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC3 PGA", ANA_ADC3_CTRL1, ADC3_PGA_ENABLE, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC4 PGA", ANA_ADC4_CTRL1, ADC4_PGA_ENABLE, 0, NULL, 0),
+
+	//DMIC PGA
+	SND_SOC_DAPM_PGA("DMIC1L PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DMIC1R PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+	
+	SND_SOC_DAPM_PGA("DMIC2L PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DMIC2R PGA", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+
+	//ADC1 DIG MUX
+	SND_SOC_DAPM_MUX("ADC1 DIG MUX", ADC_DIG_EN, ENAD1, 0, &adc1_digital_src_mux),
+
+	//ADC2 DIG MUX
+	SND_SOC_DAPM_MUX("ADC2 DIG MUX", ADC_DIG_EN, ENAD2, 0, &adc2_digital_src_mux),
+
+	//ADC3 DIG MUX
+	SND_SOC_DAPM_MUX("ADC3 DIG MUX", ADC_DIG_EN, ENAD3, 0, &adc3_digital_src_mux),
+
+	//ADC4 DIG MUX
+	SND_SOC_DAPM_MUX("ADC4 DIG MUX", ADC_DIG_EN, ENAD4, 0, &adc4_digital_src_mux),
+
+
+	//ADC12 DMIC1 MUX
+	SND_SOC_DAPM_MUX("ADC12 DMIC1 MUX", SND_SOC_NOPM, 0, 0, &adc12_dmic1_src_mux),
+
+	//ADC34 DMIC2 MUX
+	SND_SOC_DAPM_MUX("ADC34 DMIC2 MUX", SND_SOC_NOPM, 0, 0, &adc34_dmic2_src_mux),
+
+
+	//ADC1 VIR PGA
+	SND_SOC_DAPM_PGA("ADC1 VIR PGA", ANA_ADC1_CTRL1, ADC1_DSM_ENABLE, 0, NULL, 0),
+
+	//ADC2 VIR PGA
+	SND_SOC_DAPM_PGA("ADC2 VIR PGA", ANA_ADC2_CTRL1, ADC2_DSM_ENABLE, 0, NULL, 0),
+
+	//ADC3 VIR PGA
+	SND_SOC_DAPM_PGA("ADC3 VIR PGA", ANA_ADC3_CTRL1, ADC3_DSM_ENABLE, 0, NULL, 0),
+
+	//ADC4 VIR PGA
+	SND_SOC_DAPM_PGA("ADC4 VIR PGA", ANA_ADC4_CTRL1, ADC4_DSM_ENABLE, 0, NULL, 0),
+
+
+	//ADC1 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC1 DIG MIXER", SND_SOC_NOPM, 0, 0, adc1_digital_src_mixer, ARRAY_SIZE(adc1_digital_src_mixer)),
+
+	//ADC2 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC2 DIG MIXER", SND_SOC_NOPM, 0, 0, adc2_digital_src_mixer, ARRAY_SIZE(adc2_digital_src_mixer)),
+
+	//ADC3 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC3 DIG MIXER", SND_SOC_NOPM, 0, 0, adc3_digital_src_mixer, ARRAY_SIZE(adc3_digital_src_mixer)),
+
+	//ADC4 DIG MIXER
+	SND_SOC_DAPM_MIXER("ADC4 DIG MIXER", SND_SOC_NOPM, 0, 0, adc4_digital_src_mixer, ARRAY_SIZE(adc4_digital_src_mixer)),
+
+
+	//I2S TX1 CH1 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH1 MUX", SND_SOC_NOPM, 0, 0, &i2s_tx1_ch1_map_mux),
+
+	//I2S TX1 CH2 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH2 MUX", SND_SOC_NOPM, 0, 0, &i2s_tx1_ch2_map_mux),
+
+	//I2S TX1 CH3 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH3 MUX", SND_SOC_NOPM, 0, 0, &i2s_tx1_ch3_map_mux),
+
+	//I2S TX1 CH4 MUX
+	SND_SOC_DAPM_MUX("I2S TX1 CH4 MUX", SND_SOC_NOPM, 0, 0, &i2s_tx1_ch4_map_mux),
+
+
+	//AIF OUT -> (stream widget, stname must be same with codec dai_driver stream_name, which will be used to build dai widget)
+	SND_SOC_DAPM_AIF_OUT("AIF ADC OUT", "Capture", 0, SND_SOC_NOPM, 0, 0),
+};
+
+
+/*************************************** DAPM routes *******************************************/
+//ac108 dapm routes
+static const struct snd_soc_dapm_route ac108_dapm_routes[] = {
+	//MIC
+	{"MIC1 PGA", NULL, "MIC1P"},
+	{"MIC1 PGA", NULL, "MIC1N"},
+
+	{"MIC2 PGA", NULL, "MIC2P"},
+	{"MIC2 PGA", NULL, "MIC2N"},
+
+	{"MIC3 PGA", NULL, "MIC3P"},
+	{"MIC3 PGA", NULL, "MIC3N"},
+
+	{"MIC4 PGA", NULL, "MIC4P"},
+	{"MIC4 PGA", NULL, "MIC4N"},
+
+	//DMIC
+	{"DMIC1L PGA", NULL, "DMIC1"},
+	{"DMIC1R PGA", NULL, "DMIC1"},
+
+	{"DMIC2L PGA", NULL, "DMIC2"},
+	{"DMIC2R PGA", NULL, "DMIC2"},
+
+
+	//ADC1 DIG MUX
+	{"ADC1 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC1 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC1 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC1 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+	//ADC2 DIG MUX
+	{"ADC2 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC2 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC2 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC2 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+	//ADC3 DIG MUX
+	{"ADC3 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC3 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC3 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC3 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+	//ADC4 DIG MUX
+	{"ADC4 DIG MUX", "ADC1 switch", "MIC1 PGA"},
+	{"ADC4 DIG MUX", "ADC2 switch", "MIC2 PGA"},
+	{"ADC4 DIG MUX", "ADC3 switch", "MIC3 PGA"},
+	{"ADC4 DIG MUX", "ADC4 switch", "MIC4 PGA"},
+
+
+	//ADC12 DMIC1 MUX
+	{"ADC12 DMIC1 MUX", "ADC12 switch", "ADC1 DIG MUX"},
+	{"ADC12 DMIC1 MUX", "ADC12 switch", "ADC2 DIG MUX"},
+	{"ADC12 DMIC1 MUX", "DMIC1 switch", "DMIC1L PGA"},
+	{"ADC12 DMIC1 MUX", "DMIC1 switch", "DMIC1R PGA"},
+
+	//ADC34 DMIC2 MUX
+	{"ADC34 DMIC2 MUX", "ADC34 switch", "ADC3 DIG MUX"},
+	{"ADC34 DMIC2 MUX", "ADC34 switch", "ADC4 DIG MUX"},
+	{"ADC34 DMIC2 MUX", "DMIC2 switch", "DMIC2L PGA"},
+	{"ADC34 DMIC2 MUX", "DMIC2 switch", "DMIC2R PGA"},
+
+
+	//ADC1 VIR PGA
+	{"ADC1 VIR PGA", NULL, "ADC12 DMIC1 MUX"},
+
+	//ADC2 VIR PGA
+	{"ADC2 VIR PGA", NULL, "ADC12 DMIC1 MUX"},
+
+	//ADC3 VIR PGA
+	{"ADC3 VIR PGA", NULL, "ADC34 DMIC2 MUX"},
+
+	//ADC4 VIR PGA
+	{"ADC4 VIR PGA", NULL, "ADC34 DMIC2 MUX"},
+
+
+	//ADC1 DIG MIXER
+	{"ADC1 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC1 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC1 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC1 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+	//ADC2 DIG MIXER
+	{"ADC2 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC2 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC2 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC2 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+	//ADC3 DIG MIXER
+	{"ADC3 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC3 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC3 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC3 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+	//ADC4 DIG MIXER
+	{"ADC4 DIG MIXER", "ADC1 DAT switch", "ADC1 VIR PGA"},
+	{"ADC4 DIG MIXER", "ADC2 DAT switch", "ADC2 VIR PGA"},
+	{"ADC4 DIG MIXER", "ADC3 DAT switch", "ADC3 VIR PGA"},
+	{"ADC4 DIG MIXER", "ADC4 DAT switch", "ADC4 VIR PGA"},
+
+
+	//I2S TX1 CH1 MUX
+	{"I2S TX1 CH1 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH1 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH1 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH1 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+	//I2S TX1 CH2 MUX
+	{"I2S TX1 CH2 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH2 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH2 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH2 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+	//I2S TX1 CH3 MUX
+	{"I2S TX1 CH3 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH3 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH3 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH3 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+	//I2S TX1 CH4 MUX
+	{"I2S TX1 CH4 MUX", "ADC1 Sample switch", "ADC1 DIG MIXER"},
+	{"I2S TX1 CH4 MUX", "ADC2 Sample switch", "ADC2 DIG MIXER"},
+	{"I2S TX1 CH4 MUX", "ADC3 Sample switch", "ADC3 DIG MIXER"},
+	{"I2S TX1 CH4 MUX", "ADC4 Sample switch", "ADC4 DIG MIXER"},
+
+
+	//AIF OUT
+	{"AIF ADC OUT", NULL, "I2S TX1 CH1 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX1 CH2 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX1 CH3 MUX"},
+	{"AIF ADC OUT", NULL, "I2S TX1 CH4 MUX"},
+};
+
+
+static int ac108_read(u8 reg, u8 *rt_value, struct i2c_client *client)
+{
+	int ret;
+	u8 read_cmd[3] = {0};
+	u8 cmd_len = 0;
+	
+	read_cmd[0] = reg;
+	cmd_len = 1;
+	
+	if (client->adapter == NULL)
+		pr_err("ac108_read client->adapter==NULL\n");
+	
+	ret = i2c_master_send(client, read_cmd, cmd_len);
+	if (ret != cmd_len) {
+		pr_err("ac108_read error1\n");
+		return -1;
+	}
+	
+	ret = i2c_master_recv(client, rt_value, 1);
+	if (ret != 1) {
+		pr_err("ac108_read error2, ret = %d.\n", ret);
+		return -1;
+	}
+	
+	return 0;
+}
+
+static int ac108_write(u8 reg, unsigned char value, struct i2c_client *client)
+{
+	int ret = 0;
+	u8 write_cmd[2] = {0};
+	
+	write_cmd[0] = reg;
+	write_cmd[1] = value;
+	
+	ret = i2c_master_send(client, write_cmd, 2);
+	if (ret != 2) {
+		pr_err("ac108_write error->[REG-0x%02x,val-0x%02x]\n",reg,value);
+		return -1;
+	}
+	
+	return 0;
+}
+
+static int ac108_update_bits(u8 reg, u8 mask, u8 value, struct i2c_client *client)
+{
+	u8 val_old,val_new;
+
+	ac108_read(reg, &val_old, client);
+	val_new = (val_old & ~mask) | (value & mask);
+	if(val_new != val_old){
+		ac108_write(reg, val_new, client);
+	}
+
+	return 0;
+}
+#if 0 //never used
+static int ac108_multi_chips_read(u8 reg, unsigned char *rt_value)
+{
+	u8 i;
+
+	for(i=0; i<(AC108_CHANNELS_MAX+3)/4; i++){
+		ac108_read(reg, rt_value++, i2c_clt[i]);
+	}
+
+	return 0;
+}
+#endif 
+
+static int ac108_multi_chips_write(u8 reg, unsigned char value)
+{
+	u8 i;
+
+	for(i=0; i<(AC108_CHANNELS_MAX+3)/4; i++){
+		ac108_write(reg, value, i2c_clt[i]);
+	}
+	
+	return 0;
+}
+
+static int ac108_multi_chips_update_bits(u8 reg, u8 mask, u8 value)
+{
+	u8 i;
+	
+	for(i=0; i<(AC108_CHANNELS_MAX+3)/4; i++){
+		ac108_update_bits(reg, mask, value, i2c_clt[i]);
+	}
+
+	return 0;
+}
+
+/**
+ * snd_ac108_get_volsw - single mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_ac108_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol){
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	int chip = mc->autodisable;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	u8 val;
+	int ret;
+
+	ret = ac108_read(reg, &val, i2c_clt[chip]);
+
+	if (ret < 0)
+		return ret;
+
+	val = (val >> shift) & mask;
+
+	ucontrol->value.integer.value[0] = val - min;
+	if (invert)
+		ucontrol->value.integer.value[0] =
+			max - ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+/**
+ * snd_ac108_put_volsw - single mixer put callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a single mixer control, or a double mixer
+ * control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int snd_ac108_put_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol){
+	struct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;
+	unsigned int reg = mc->reg;
+	unsigned int shift = mc->shift;
+	int max = mc->max;
+	int min = mc->min;
+	unsigned int sign_bit = mc->sign_bit;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int invert = mc->invert;
+	int err;
+	unsigned int val, val_mask;
+	int chip = mc->autodisable;
+
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
+	if (invert)
+		val = max - val;
+	val_mask = mask << shift;
+	val = val << shift;
+
+	err = ac108_update_bits(reg, val_mask, val, i2c_clt[chip]);
+	if (err < 0)
+		return err;
+
+
+	return err;
+}
+#define SOC_AC108_SINGLE_TLV(xname, reg, shift, max, invert, chip, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, .get = snd_ac108_get_volsw,\
+	.put = snd_ac108_put_volsw, \
+	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, chip) }
+
+static const struct snd_kcontrol_new ac108_volume_snd_controls[] = {
+	/*0x70: ADC1 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH1 volume", ADC1_DVOL_CTRL, 0, 0xff, 0, 0, ch_digital_vol_tlv),
+	/*0x71: ADC2 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH2 volume", ADC2_DVOL_CTRL, 0, 0xff, 0, 0, ch_digital_vol_tlv),
+	/*0x72: ADC3 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH3 volume", ADC3_DVOL_CTRL, 0, 0xff, 0, 0, ch_digital_vol_tlv),
+	/*0x73: ADC4 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH4 volume", ADC4_DVOL_CTRL, 0, 0xff, 0, 0, ch_digital_vol_tlv),
+
+	/*0x90: Analog PGA1 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC1 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, 0, adc_pga_gain_tlv),
+	/*0x91: Analog PGA2 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC2 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, 0, adc_pga_gain_tlv),
+	/*0x92: Analog PGA3 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC3 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, 0, adc_pga_gain_tlv),
+	/*0x93: Analog PGA4 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC4 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, 0, adc_pga_gain_tlv),
+
+	/*0x70: ADC1 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH5 volume", ADC1_DVOL_CTRL, 0, 0xff, 0, 1, ch_digital_vol_tlv),
+	/*0x71: ADC2 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH6 volume", ADC2_DVOL_CTRL, 0, 0xff, 0, 1, ch_digital_vol_tlv),
+	/*0x72: ADC3 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH7 volume", ADC3_DVOL_CTRL, 0, 0xff, 0, 1, ch_digital_vol_tlv),
+	/*0x73: ADC4 Digital Channel Volume Control Register*/
+	SOC_AC108_SINGLE_TLV("CH8 volume", ADC4_DVOL_CTRL, 0, 0xff, 0, 1, ch_digital_vol_tlv),
+
+	/*0x90: Analog PGA1 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC5 PGA gain", ANA_PGA1_CTRL, ADC1_ANALOG_PGA, 0x1f, 0, 1, adc_pga_gain_tlv),
+	/*0x91: Analog PGA2 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC6 PGA gain", ANA_PGA2_CTRL, ADC2_ANALOG_PGA, 0x1f, 0, 1, adc_pga_gain_tlv),
+	/*0x92: Analog PGA3 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC7 PGA gain", ANA_PGA3_CTRL, ADC3_ANALOG_PGA, 0x1f, 0, 1, adc_pga_gain_tlv),
+	/*0x93: Analog PGA4 Control Register*/
+	SOC_AC108_SINGLE_TLV("ADC8 PGA gain", ANA_PGA4_CTRL, ADC4_ANALOG_PGA, 0x1f, 0, 1, adc_pga_gain_tlv),
+};
+
+
+
+static void ac108_hw_init(struct i2c_client *i2c)
+{
+	/*** Chip reset ***/
+	//ac108_write(CHIP_AUDIO_RST, 0x12, i2c);	/*0x00=0x12: reset all registers to their default state*/
+
+#if !AC108_DMIC_EN
+	/*** Analog voltage enable ***/
+	ac108_write(PWR_CTRL6, 0x01, i2c);		/*0x06=0x01: Enable Analog LDO*/
+	ac108_write(PWR_CTRL7, 0x9b, i2c);		/*0x07=0x9b: VREF faststart Enable, Enable VREF @ 3.4V (5V) or 3.1V (3.3V) (needed for Analog LDO and MICBIAS)*/
+	ac108_write(PWR_CTRL9, 0x81, i2c);		/*0x09=0x81: VREFP faststart Enable, Enable VREFP (needed by all audio input channels)*/
+	ac108_write(ANA_ADC3_CTRL7, 0x03, i2c);	/*Control bias current for DSM integrator opamps*/
+#endif
+
+	/*** SYSCLK Config ***/
+	ac108_update_bits(SYSCLK_CTRL, 0x1<<SYSCLK_EN, 0x1<<SYSCLK_EN, i2c);	/*SYSCLK Enable*/
+	ac108_write(MOD_CLK_EN, 0x93, i2c);		/*0x21=0x93: Module clock enable<I2S, ADC digital, MIC offset Calibration, ADC analog>*/
+	ac108_write(MOD_RST_CTRL, 0x93, i2c);	/*0x22=0x93: Module reset de-asserted<I2S, ADC digital, MIC offset Calibration, ADC analog>*/
+
+	/*** I2S Common Config ***/
+	ac108_update_bits(I2S_CTRL, 0x1<<SDO1_EN | 0x1<<SDO2_EN, 0x1<<SDO1_EN | !!AC108_SDO2_EN<<SDO2_EN, i2c);	/*SDO1 enable, SDO2 Enable*/
+	ac108_update_bits(I2S_BCLK_CTRL, 0x1<<EDGE_TRANSFER, 0x0<<EDGE_TRANSFER, i2c);	/*SDO drive data and SDI sample data at the different BCLK edge*/
+	ac108_update_bits(I2S_LRCK_CTRL1, 0x3<<LRCK_PERIODH, ((AC108_LRCK_PERIOD-1) >> 8)<<LRCK_PERIODH, i2c);
+	ac108_write(I2S_LRCK_CTRL2, (u8)(AC108_LRCK_PERIOD-1), i2c);	/*config LRCK period: 16bit * 8ch = 128, 32bit * 8ch = 256, 32bit *16ch =512*/
+	/*Encoding mode enable, Turn to hi-z state (TDM) when not transferring slot*/
+	ac108_update_bits(I2S_FMT_CTRL1, 0x1<<ENCD_SEL | 0x1<<TX_SLOT_HIZ | 0x1<<TX_STATE, !!AC108_ENCODING_EN<<ENCD_SEL | 0x0<<TX_SLOT_HIZ | 0x1<<TX_STATE, i2c);
+	ac108_update_bits(I2S_FMT_CTRL2, 0x7<<SLOT_WIDTH_SEL, (AC108_SLOT_WIDTH == 16 ? 3 : AC108_SLOT_WIDTH == 32 ? 7 : 0)<<SLOT_WIDTH_SEL, i2c);	/*16bit or 32bit Slot Width*/
+	/*0x36=0x70: TX MSB first, TX2 Mute, Transfer 0 after each sample in each slot(sample resolution < slot width), LRCK = 1 BCLK width (short frame), Linear PCM Data Mode*/
+	ac108_write(I2S_FMT_CTRL3, AC108_SDO2_EN ? 0x60 : 0x70, i2c);
+	
+	ac108_write(I2S_TX1_CHMP_CTRL1, 0x04, i2c);		/*0x3C=0xe4: TX1 CHn Map to CHn adc sample, n=[1,4]*/
+	ac108_write(I2S_TX1_CHMP_CTRL2, 0x00, i2c);		/*0x3D=0xe4: TX1 CHn Map to CH(n-4) adc sample, n=[5,8]*/
+	ac108_write(I2S_TX1_CHMP_CTRL3, 0x00, i2c);		/*0x3E=0xe4: TX1 CHn Map to CH(n-8) adc sample, n=[9,12]*/
+	ac108_write(I2S_TX1_CHMP_CTRL4, 0x00, i2c);		/*0x3F=0xe4: TX1 CHn Map to CH(n-12) adc sample, n=[13,16]*/
+#if AC108_SDO2_EN
+	ac108_write(I2S_TX2_CHMP_CTRL1, 0x0e, i2c); 	/*0x44=0x4e: TX2 CH1/2 Map to CH3/4 adc sample, TX2 CH3/4 Map to CH1/2 adc sample*/
+	ac108_write(I2S_TX2_CHMP_CTRL2, 0x00, i2c); 	/*0x45=0xe4: TX2 CHn Map to CH(n-4) adc sample, n=[5,8]*/
+	ac108_write(I2S_TX2_CHMP_CTRL3, 0x00, i2c); 	/*0x46=0xe4: TX2 CHn Map to CH(n-8) adc sample, n=[9,12]*/
+	ac108_write(I2S_TX2_CHMP_CTRL4, 0x00, i2c); 	/*0x47=0xe4: TX2 CHn Map to CH(n-12) adc sample, n=[13,16]*/
+#endif
+
+	/*** ADC DIG part Config***/
+	//ac108_write(ADC_SPRC, 0x03, i2c);					/*0x60=0x03: ADC Sample Rate 16KHz*/
+	ac108_write(ADC_DIG_EN, 0x1f, i2c);				/*0x61=0x1f: Digital part globe enable, ADCs digital part enable*/
+	ac108_write(ANA_ADC4_CTRL7, 0x0f, i2c);			/*0xBB=0x0f: Gating ADCs CLK de-asserted (ADCs CLK Enable)*/
+	
+#if AC108_ADC_PATTERN_SEL
+	ac108_write(HPF_EN, 0x00, i2c);									/*0x66=0x00: Digital ADCs channel HPF disable*/
+	ac108_write(ADC_DIG_DEBUG, AC108_ADC_PATTERN_SEL & 0x7, i2c);	/*0X7F=0x00: ADC pattern select: 0:ADC normal, 1:0x5A5A5A, 2:0x123456, 3:0x00, 4~7:I2S RX data*/
+#endif
+
+#if !AC108_DMIC_EN
+	/*** ADCs analog PGA gain Config***/
+//	ac108_write(ANA_PGA1_CTRL, AC108_PGA_GAIN<<1, i2c);				/*0x90=0x3d: ADC1 PGA gain 30.5dB*/
+//	ac108_write(ANA_PGA2_CTRL, AC108_PGA_GAIN<<1, i2c);				/*0x91=0x3d: ADC2 PGA gain 30.5dB*/
+//	ac108_write(ANA_PGA3_CTRL, AC108_PGA_GAIN<<1, i2c);				/*0x92=0x3d: ADC3 PGA gain 30.5dB*/
+//	ac108_write(ANA_PGA4_CTRL, AC108_PGA_GAIN<<1, i2c);				/*0x93=0x3d: ADC4 PGA gain 30.5dB*/
+
+	/*** enable AAF/ADC/PGA  and UnMute Config ***/
+	ac108_write(ANA_ADC1_CTRL1, 0x07, i2c);			/*0xA0=0x07: ADC1 AAF & ADC enable, ADC1 PGA enable, ADC1 MICBIAS enable and UnMute*/
+	ac108_write(ANA_ADC2_CTRL1, 0x07, i2c);			/*0xA7=0x07: ADC2 AAF & ADC enable, ADC2 PGA enable, ADC2 MICBIAS enable and UnMute*/
+	ac108_write(ANA_ADC3_CTRL1, 0x07, i2c);			/*0xAE=0x07: ADC3 AAF & ADC enable, ADC3 PGA enable, ADC3 MICBIAS enable and UnMute*/
+	ac108_write(ANA_ADC4_CTRL1, 0x07, i2c);			/*0xB5=0x07: ADC4 AAF & ADC enable, ADC4 PGA enable, ADC4 MICBIAS enable and UnMute*/
+
+	mdelay(50);										/*delay 50ms to let VREF/VRP faststart powerup stable, then disable faststart*/
+	ac108_update_bits(PWR_CTRL7, 0x1<<VREF_FASTSTART_ENABLE, 0x0<<VREF_FASTSTART_ENABLE, i2c);		/*VREF faststart disable*/
+	ac108_update_bits(PWR_CTRL9, 0x1<<VREFP_FASTSTART_ENABLE, 0x0<<VREFP_FASTSTART_ENABLE, i2c);	/*VREFP faststart disable*/
+#else
+	/*DMIC module Enable*/
+	ac108_write(DMIC_EN, 0x03, i2c);				/*DMIC1/2 Enable, while ADC DIG source select DMIC1/2*/
+	ac108_write(GPIO_CFG1, 0xee, i2c);				/*GPIO1 as DMIC1_DAT, GPIO2 as DMIC_CLK*/
+	ac108_write(GPIO_CFG2, 0x7e, i2c);				/*GPIO3 as DMIC2_DAT*/
+#endif
+}
+
+
+static int ac108_set_sysclk(struct snd_soc_dai *dai, int clk_id, unsigned int freq, int dir)
+{
+	AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+	switch(clk_id){
+		case SYSCLK_SRC_MCLK:
+			AC108_DEBUG("AC108 SYSCLK source select MCLK\n\n");
+			ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1<<SYSCLK_SRC, 0x0<<SYSCLK_SRC);	//System Clock Source Select MCLK
+			break;
+		case SYSCLK_SRC_PLL:
+			AC108_DEBUG("AC108 SYSCLK source select PLL\n\n");
+			ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1<<SYSCLK_SRC, 0x1<<SYSCLK_SRC);	//System Clock Source Select PLL
+			break;
+		default:
+			pr_err("AC108 SYSCLK source config error:%d\n\n",clk_id);
+			return -EINVAL;
+	}
+
+	//SYSCLK Enable
+	ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1<<SYSCLK_EN, 0x1<<SYSCLK_EN);
+	return 0;
+}
+
+static int ac108_set_pll(struct snd_soc_dai *dai, int pll_id, int source, unsigned int freq_in, unsigned int freq_out)
+{
+	u32 i,m1,m2,n,k1,k2;
+	AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+
+	//if (!freq_out)	return 0;
+
+	if (freq_in < 128000 || freq_in > 24576000) {
+		pr_err("AC108 PLLCLK source input freq only support [128K,24M],while now %u\n\n",freq_in);
+		return -EINVAL;
+	} else if ((freq_in == 24576000 || freq_in == 22579200) && pll_id == SYSCLK_SRC_MCLK) {
+		//System Clock Source Select MCLK, SYSCLK Enable
+		AC108_DEBUG("AC108 don't need to use PLL\n\n");
+		ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1<<SYSCLK_SRC | 0x1<<SYSCLK_EN, 0x0<<SYSCLK_SRC | 0x1<<SYSCLK_EN);
+		return 0;	//Don't need to use PLL
+	}
+
+	//PLL Clock Source Select
+	switch(pll_id){
+		case PLLCLK_SRC_MCLK:
+			AC108_DEBUG("AC108 PLLCLK input source select MCLK\n");
+			ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3<<PLLCLK_SRC, 0x0<<PLLCLK_SRC);
+			break;
+		case PLLCLK_SRC_BCLK:
+			AC108_DEBUG("AC108 PLLCLK input source select BCLK\n");
+			ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3<<PLLCLK_SRC, 0x1<<PLLCLK_SRC);
+			break;
+		case PLLCLK_SRC_GPIO2:
+			AC108_DEBUG("AC108 PLLCLK input source select GPIO2\n");
+			ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3<<PLLCLK_SRC, 0x2<<PLLCLK_SRC);
+			break;
+		case PLLCLK_SRC_GPIO3:
+			AC108_DEBUG("AC108 PLLCLK input source select GPIO3\n");
+			ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x3<<PLLCLK_SRC, 0x3<<PLLCLK_SRC);
+			break;
+		default:
+			pr_err("AC108 PLLCLK source config error:%d\n\n",pll_id);
+			return -EINVAL;
+	}
+
+	//FOUT =(FIN * N) / [(M1+1) * (M2+1)*(K1+1)*(K2+1)] ;
+	for(i=0; i<ARRAY_SIZE(ac108_pll_div); i++){
+		if(ac108_pll_div[i].freq_in == freq_in ){
+			m1 = ac108_pll_div[i].m1;
+			m2 = ac108_pll_div[i].m2;
+			n = ac108_pll_div[i].n;
+			k1 = ac108_pll_div[i].k1;
+			k2 = ac108_pll_div[i].k2;
+			AC108_DEBUG("AC108 PLL freq_in match:%u, freq_out:%u\n\n",freq_in,ac108_pll_div[i].freq_out);
+			break;
+		}
+	}
+
+	if(i == ARRAY_SIZE(ac108_pll_div)){
+		pr_err("AC108 don't match PLLCLK freq_in and freq_out table\n\n");
+		return -EINVAL;
+	}
+
+	//Config PLL DIV param M1/M2/N/K1/K2
+	ac108_multi_chips_update_bits(PLL_CTRL2, 0x1f<<PLL_PREDIV1 | 0x1<<PLL_PREDIV2, m1<<PLL_PREDIV1 | m2<<PLL_PREDIV2);
+	ac108_multi_chips_update_bits(PLL_CTRL3, 0x3<<PLL_LOOPDIV_MSB, (n>>8)<<PLL_LOOPDIV_MSB);
+	ac108_multi_chips_update_bits(PLL_CTRL4, 0xff<<PLL_LOOPDIV_LSB, (u8)n<<PLL_LOOPDIV_LSB);
+	ac108_multi_chips_update_bits(PLL_CTRL5, 0x1f<<PLL_POSTDIV1 | 0x1<<PLL_POSTDIV2, k1<<PLL_POSTDIV1 | k2<<PLL_POSTDIV2);
+
+	//Config PLL module current
+	ac108_multi_chips_update_bits(PLL_CTRL1, 0x7<<PLL_IBIAS, 0x0<<PLL_IBIAS);
+	//ac108_multi_chips_update_bits(PLL_CTRL6, 0x1f<<PLL_CP, 0x0<<PLL_CP);
+
+	//PLL module enable
+	ac108_multi_chips_update_bits(PLL_LOCK_CTRL, 0x1<<PLL_LOCK_EN, 0x1<<PLL_LOCK_EN);						//PLL CLK lock enable
+	ac108_multi_chips_update_bits(PLL_CTRL1, 0x1<<PLL_EN | 0x1<<PLL_COM_EN, 0x1<<PLL_EN | 0x1<<PLL_COM_EN);	//PLL Common voltage Enable, PLL Enable
+
+	//PLLCLK Enable, System Clock Source Select PLL, SYSCLK Enable
+	ac108_multi_chips_update_bits(SYSCLK_CTRL, 0x1<<PLLCLK_EN | 0x1<<SYSCLK_SRC | 0x1<<SYSCLK_EN, 0x1<<PLLCLK_EN | 0x1<<SYSCLK_SRC | 0x1<<SYSCLK_EN);
+	
+	return 0;
+}
+
+static int ac108_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)
+{
+
+	u32 i,bclk_div,bclk_div_reg_val;
+	AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+
+	if(!div_id){	//use div_id to judge Master/Slave mode,  0: Slave mode, 1: Master mode
+		AC108_DEBUG("AC108 work as Slave mode, don't need to config BCLK_DIV\n\n");
+		return 0;
+	}
+
+	bclk_div = div/(AC108_LRCK_PERIOD);		//default PCM mode
+	//bclk_div = div/(2*AC108_LRCK_PERIOD);	//I2S/LJ/RJ mode
+
+	for(i=0; i<ARRAY_SIZE(ac108_bclk_div); i++){
+		if(ac108_bclk_div[i].real_val == bclk_div){
+			bclk_div_reg_val = ac108_bclk_div[i].reg_val;
+			AC108_DEBUG("AC108 set BCLK_DIV_[%u]\n\n",bclk_div);
+			break;
+		}
+	}
+	
+	if(i == ARRAY_SIZE(ac108_bclk_div)){
+		pr_err("AC108 don't support BCLK_DIV_[%u]\n\n",bclk_div);
+		return -EINVAL;
+	}
+
+	//AC108 set BCLK DIV
+	ac108_multi_chips_update_bits(I2S_BCLK_CTRL, 0xf<<BCLKDIV, bclk_div_reg_val<<BCLKDIV);
+	return 0;
+}
+
+static int ac108_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	u8 i, tx_offset, i2s_mode, lrck_polarity, brck_polarity;
+	struct ac108_priv *ac108 = dev_get_drvdata(dai->dev);
+
+	AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+	//AC108 config Master/Slave mode
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+		case SND_SOC_DAIFMT_CBM_CFM:	//AC108 Master
+			AC108_DEBUG("AC108 set to work as Master\n");
+			ac108_update_bits(I2S_CTRL, 0x3<<LRCK_IOEN, 0x3<<LRCK_IOEN, ac108->i2c);	//BCLK & LRCK output
+			break;
+		case SND_SOC_DAIFMT_CBS_CFS:	//AC108 Slave
+			AC108_DEBUG("AC108 set to work as Slave\n");
+			ac108_update_bits(I2S_CTRL, 0x3<<LRCK_IOEN, 0x0<<LRCK_IOEN, ac108->i2c);	//BCLK & LRCK input
+			break;
+		default:
+			pr_err("AC108 Master/Slave mode config error:%u\n\n",(fmt & SND_SOC_DAIFMT_MASTER_MASK)>>12);
+			return -EINVAL;
+	}
+	for(i=0; i<(AC108_CHANNELS_MAX+3)/4; i++){	//multi_chips: only one chip set as Master, and the others also need to set as Slave
+		if(i2c_clt[i] == ac108->i2c) continue;
+		ac108_update_bits(I2S_CTRL, 0x3<<LRCK_IOEN, 0x0<<LRCK_IOEN, i2c_clt[i]);
+	}
+
+	//AC108 config I2S/LJ/RJ/PCM format
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			AC108_DEBUG("AC108 config I2S format\n");
+			i2s_mode = LEFT_JUSTIFIED_FORMAT;
+			tx_offset = 1;
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			AC108_DEBUG("AC108 config RIGHT-JUSTIFIED format\n");
+			i2s_mode = RIGHT_JUSTIFIED_FORMAT;
+			tx_offset = 0;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			AC108_DEBUG("AC108 config LEFT-JUSTIFIED format\n");
+			i2s_mode = LEFT_JUSTIFIED_FORMAT;
+			tx_offset = 0;
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+			AC108_DEBUG("AC108 config PCM-A format\n");
+			i2s_mode = PCM_FORMAT;
+			tx_offset = 1;
+			break;
+		case SND_SOC_DAIFMT_DSP_B:
+			AC108_DEBUG("AC108 config PCM-B format\n");
+			i2s_mode = PCM_FORMAT;
+			tx_offset = 0;
+			break;
+		default:
+			pr_err("AC108 I2S format config error:%u\n\n",fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+			return -EINVAL;
+	}
+	ac108_multi_chips_update_bits(I2S_FMT_CTRL1, 0x3<<MODE_SEL | 0x1<<TX2_OFFSET | 0x1<<TX1_OFFSET,\
+		i2s_mode<<MODE_SEL | tx_offset<<TX2_OFFSET | tx_offset<<TX1_OFFSET);
+
+	//AC108 config BCLK&LRCK polarity
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_normal,LRCK_normal\n");
+			brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
+			lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:
+			AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_normal,LRCK_invert\n");
+			brck_polarity = BCLK_NORMAL_DRIVE_N_SAMPLE_P;
+			lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_invert,LRCK_normal\n");
+			brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
+			lrck_polarity = LRCK_LEFT_LOW_RIGHT_HIGH;
+			break;
+		case SND_SOC_DAIFMT_IB_IF:
+			AC108_DEBUG("AC108 config BCLK&LRCK polarity: BCLK_invert,LRCK_invert\n");
+			brck_polarity = BCLK_INVERT_DRIVE_P_SAMPLE_N;
+			lrck_polarity = LRCK_LEFT_HIGH_RIGHT_LOW;
+			break;
+		default:
+			pr_err("AC108 config BCLK/LRCLK polarity error:%u\n\n",(fmt & SND_SOC_DAIFMT_INV_MASK)>>8);
+			return -EINVAL;
+	}
+	ac108_multi_chips_update_bits(I2S_BCLK_CTRL,  0x1<<BCLK_POLARITY, brck_polarity<<BCLK_POLARITY);
+	ac108_multi_chips_update_bits(I2S_LRCK_CTRL1, 0x1<<LRCK_POLARITY, lrck_polarity<<LRCK_POLARITY);
+	
+	return 0;
+}
+
+static int ac108_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	u16 i, channels, sample_resolution;
+
+	AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+	//AC108 hw init
+	for(i=0; i<(AC108_CHANNELS_MAX+3)/4; i++){	//(params_channels(params)+3)/4
+		ac108_hw_init(i2c_clt[i]);
+	}
+
+	//AC108 set sample rate
+	for(i=0; i<ARRAY_SIZE(ac108_sample_rate); i++){
+		if(ac108_sample_rate[i].real_val == params_rate(params) / (AC108_ENCODING_EN ? AC108_ENCODING_CH_NUMS/2 : 1)){
+			ac108_multi_chips_update_bits(ADC_SPRC, 0xf<<ADC_FS_I2S1, ac108_sample_rate[i].reg_val<<ADC_FS_I2S1);
+			break;
+		}
+	}
+
+	//AC108 set channels
+	channels = params_channels(params) * (AC108_ENCODING_EN ? AC108_ENCODING_CH_NUMS/2 : 1) / (AC108_SDO2_EN ? 2 :1);
+	AC108_DEBUG("\n--->channel:%d \n",channels);
+	for(i=0; i<=(channels+3)/4; i++){
+		ac108_write(I2S_TX1_CTRL1, 0x01, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL2, 0x03, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL3, 0x00, i2c_clt[i]);
+	}
+	for(i=0; i<= (channels+3)/4; i++){
+		//channels_en = (channels >= 4*(i+1)) ? 0x000f<<(4*i) : ((1<<(channels%4))-1)<<(4*i);
+		ac108_write(I2S_TX2_CTRL1, 0x01, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL2, 0x03, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL3, 0x00, i2c_clt[i]);
+	}
+#if 0
+	for(i=0; i<=(channels+3)/4; i++){
+		channels_en = (channels >= 4*(i+1)) ? 0x000f<<(4*i) : ((1<<(channels%4))-1)<<(4*i);
+		AC108_DEBUG("\n--->channel1:%x %x %x\n ",channels,channels_en,channels_en>>8);
+		ac108_write(I2S_TX1_CTRL1, channels-1, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL2, (u8)channels_en, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL3, channels_en>>8, i2c_clt[i]);
+	}
+	for(; i<(AC108_CHANNELS_MAX+3)/4; i++){
+		ac108_write(I2S_TX1_CTRL1, 0, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL2, 0, i2c_clt[i]);
+		ac108_write(I2S_TX1_CTRL3, 0, i2c_clt[i]);
+	}
+
+#if AC108_SDO2_EN
+	for(i=0; i<= (channels+3)/4; i++){
+		channels_en = 0x0f;
+		//channels_en = (channels >= 4*(i+1)) ? 0x000f<<(4*i) : ((1<<(channels%4))-1)<<(4*i);
+		AC108_DEBUG("\n--->channel2:%x %x %x\n ",channels,channels_en,channels_en>>8);
+		ac108_write(I2S_TX2_CTRL1, channels-1, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL2, (u8)channels_en, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL3, channels_en>>8, i2c_clt[i]);
+	}
+	for(; i<(AC108_CHANNELS_MAX+3)/4; i++){
+		ac108_write(I2S_TX2_CTRL1, 0, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL2, 0, i2c_clt[i]);
+		ac108_write(I2S_TX2_CTRL3, 0, i2c_clt[i]);
+	}
+#endif
+#endif
+	//AC108 set sample resorution
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		sample_resolution = 8;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		sample_resolution = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		sample_resolution = 20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		sample_resolution = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		sample_resolution = 32;
+		break;
+	default:
+		dev_err(dai->dev, "AC108 don't supported the sample resolution: %u\n", params_format(params));
+		return -EINVAL;
+	}
+	
+  #if 0//AC108_ENCODING_EN
+	if(sample_resolution <= 24 && sample_resolution != 16)	sample_resolution += 4;		//TX Encoding mode, SR add 4bits to mark channel number
+  #endif
+	for(i=0; i<ARRAY_SIZE(ac108_sample_resolution); i++){
+		if(ac108_sample_resolution[i].real_val == sample_resolution){
+			ac108_multi_chips_update_bits(I2S_FMT_CTRL2, 0x7<<SAMPLE_RESOLUTION, ac108_sample_resolution[i].reg_val<<SAMPLE_RESOLUTION);
+			break;
+		}
+	}
+
+	//AC108 TX enable, Globle enable
+	ac108_multi_chips_update_bits(I2S_CTRL, 0x1<<TXEN | 0x1<<GEN, 0x1<<TXEN | 0x1<<GEN);
+
+	return 0;
+}
+
+static int ac108_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)
+{
+	AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+
+#if !AC108_IDLE_RESET_EN
+	//repair PLL version no sync problem
+	ac108_multi_chips_update_bits(PLL_CTRL1, 0x1<<PLL_EN | 0x1<<PLL_COM_EN, 0x0<<PLL_EN | 0x0<<PLL_COM_EN);
+	ac108_multi_chips_update_bits(MOD_CLK_EN, 0x1<<ADC_DIGITAL, 0x0<<ADC_DIGITAL);
+	ac108_multi_chips_update_bits(MOD_RST_CTRL, 0x1<<ADC_DIGITAL, 0x0<<ADC_DIGITAL);
+
+	//AC108 I2S Globle disable
+	ac108_multi_chips_update_bits(I2S_CTRL, 0x1<<GEN, 0x0<<GEN);
+	
+#else
+
+	//AC108_DEBUG("AC108 reset all register to their default value\n\n");
+	//ac108_multi_chips_write(CHIP_AUDIO_RST, 0x12);		//if config TX Encoding mode, also disable BCLK
+#endif
+
+	return 0;
+}
+
+
+/*** define  ac108  dai_ops  struct ***/
+static const struct snd_soc_dai_ops ac108_dai_ops = {
+	/*DAI clocking configuration*/
+	.set_sysclk = ac108_set_sysclk,
+	.set_pll = ac108_set_pll,
+	.set_clkdiv = ac108_set_clkdiv,
+
+	/*ALSA PCM audio operations*/
+	.hw_params = ac108_hw_params,
+	.hw_free = ac108_hw_free,
+
+	/*DAI format configuration*/
+	.set_fmt = ac108_set_fmt,
+};
+
+/*** define  ac108  dai_driver struct ***/
+#if AC108_CHANNELS_MAX > 0
+static  struct snd_soc_dai_driver ac108_dai0 = {
+	.name = "ac108-pcm0",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = AC108_CHANNELS_MAX,
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+#endif
+
+#if AC108_CHANNELS_MAX > 4
+static  struct snd_soc_dai_driver ac108_dai1 = {
+	.name = "ac108-pcm1",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = AC108_CHANNELS_MAX,
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+#endif
+
+#if AC108_CHANNELS_MAX > 8
+static  struct snd_soc_dai_driver ac108_dai2 = {
+	.name = "ac108-pcm2",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = AC108_CHANNELS_MAX,
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+#endif
+
+#if AC108_CHANNELS_MAX > 12
+static  struct snd_soc_dai_driver ac108_dai3 = {
+	.name = "ac108-pcm3",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = AC108_CHANNELS_MAX,
+		.rates = AC108_RATES,
+		.formats = AC108_FORMATS,
+	},
+	.ops = &ac108_dai_ops,
+};
+#endif
+
+static  struct snd_soc_dai_driver *ac108_dai[] = {
+#if AC108_CHANNELS_MAX > 0
+	&ac108_dai0,
+#endif
+
+#if AC108_CHANNELS_MAX > 4
+	&ac108_dai1,
+#endif
+	
+#if AC108_CHANNELS_MAX > 8
+	&ac108_dai2,
+#endif
+
+#if AC108_CHANNELS_MAX > 12
+	&ac108_dai3,
+#endif
+};
+
+static int ac108_probe(struct snd_soc_codec *codec)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+	int ret = 0;
+	
+	AC108_DEBUG("AC108 reset all register to their default value\n\n");
+	ac108_multi_chips_write(CHIP_AUDIO_RST, 0x12);		//if config TX Encoding mode, also disable BCLK
+														//	
+
+#if !AC108_CODEC_RW_TEST_EN
+	//ret = snd_soc_codec_set_cache_io(codec, ac108_regmap_config.reg_bits, ac108_regmap_config.val_bits, CONFIG_REGMAP_I2C);//8,8
+#else
+	codec->control_data = devm_regmap_init_i2c(ac108->i2c, &ac108_regmap_config);
+	ret = PTR_RET(codec->control_data);
+#endif
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+
+	ac108->codec = codec;
+
+	return 0;
+}
+
+static int ac108_remove(struct snd_soc_codec *codec)
+{
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int ac108_suspend(struct snd_soc_codec *codec)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+
+#if AC108_MATCH_DTS_EN
+	if (regulator_en && !IS_ERR(ac108->vol_supply.vcc3v3)) {
+		regulator_disable(ac108->vol_supply.vcc3v3);
+		regulator_en = 0;
+	}
+#endif
+
+	return 0;
+}
+
+static int ac108_resume(struct snd_soc_codec *codec)
+{
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+	int ret;
+	u8 i;
+
+#if AC108_MATCH_DTS_EN
+	if (!regulator_en && !IS_ERR(ac108->vol_supply.vcc3v3)) {
+		ret = regulator_enable(ac108->vol_supply.vcc3v3);
+		if(ret != 0)
+			pr_err("[AC108] %s: some error happen, fail to enable regulator!\n", __func__);
+		regulator_en = 1;
+	}
+#endif
+
+#if !AC108_IDLE_RESET_EN
+	for(i=0; i<(AC108_CHANNELS_MAX+3)/4; i++){
+		ac108_hw_init(i2c_clt[i]);
+	}
+#endif
+
+	return 0;
+}
+
+#else
+
+#define ac108_suspend 	NULL
+#define ac108_resume	NULL
+
+#endif
+
+#if AC108_CODEC_RW_TEST_EN
+static unsigned int ac108_codec_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	//AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+	u8 val_r;
+	struct ac108_priv *ac108 = dev_get_drvdata(codec->dev);
+
+	ac108_read(reg, &val_r, ac108->i2c);
+	return val_r;
+}
+
+static int ac108_codec_write(struct snd_soc_codec *codec, unsigned int reg, unsigned int value)
+{
+	//AC108_DEBUG("\n--->%s\n",__FUNCTION__);
+	ac108_multi_chips_write(reg, value);
+	return 0;
+}
+
+#endif
+
+/*** define  ac108  codec_driver struct ***/
+static const struct snd_soc_codec_driver ac108_soc_codec_driver = {
+	.probe = ac108_probe,
+	.remove = ac108_remove,
+	.suspend = ac108_suspend,
+	.resume = ac108_resume,
+
+#if AC108_CODEC_RW_TEST_EN
+	.read = ac108_codec_read,
+	.write = ac108_codec_write,
+#endif
+
+	.controls = ac108_volume_snd_controls,
+	.num_controls = ARRAY_SIZE(ac108_volume_snd_controls),
+
+#if AC108_DAPM_TEST_EN
+	.controls = ac108_controls,
+	.num_controls = ARRAY_SIZE(ac108_controls),
+	.dapm_widgets = ac108_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(ac108_dapm_widgets),
+	.dapm_routes = ac108_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(ac108_dapm_routes),
+#endif
+};
+
+
+static ssize_t ac108_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int val=0, flag=0;
+	u8 i=0, reg, num, value_w, value_r;
+	
+	struct ac108_priv *ac108 = dev_get_drvdata(dev);
+	val = simple_strtol(buf, NULL, 16);
+	flag = (val >> 16) & 0xFF;
+	
+	if (flag) {
+		reg = (val >> 8) & 0xFF;
+		value_w = val & 0xFF;
+		printk("\nWrite: start REG:0x%02x,val:0x%02x,count:0x%02x\n", reg, value_w, flag);
+		while(flag--){
+			ac108_write(reg, value_w, ac108->i2c);
+			printk("Write 0x%02x to REG:0x%02x\n", value_w, reg);
+			reg++;
+		}
+	} else {
+		reg = (val >> 8) & 0xFF;
+		num = val & 0xff;
+		printk("\nRead: start REG:0x%02x,count:0x%02x\n", reg, num);
+		
+		do {
+			value_r = 0;
+			ac108_read(reg, &value_r, ac108->i2c);
+			printk("REG[0x%02x]: 0x%02x;  ", reg, value_r);
+			reg++;
+			i++;
+			if ((i==num) || (i%4==0))	printk("\n");
+		} while (i<num);
+	}
+	
+	return count;
+}
+
+static ssize_t ac108_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	printk("echo flag|reg|val > ac108\n");
+	printk("eg read star addres=0x06,count 0x10:echo 0610 >ac108\n");
+	printk("eg write star addres=0x90,value=0x3c,count=4:echo 4903c >ac108\n");
+	//printk("eg write value:0xfe to address:0x06 :echo 106fe > ac108\n");
+	return 0;
+}
+
+static DEVICE_ATTR(ac108, 0644, ac108_show, ac108_store);
+
+static struct attribute *ac108_debug_attrs[] = {
+	&dev_attr_ac108.attr,
+	NULL,
+};
+
+static struct attribute_group ac108_debug_attr_group = {
+	.name   = "ac108_debug",
+	.attrs  = ac108_debug_attrs,
+};
+
+
+static int ac108_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *i2c_id)
+{
+	struct ac108_priv *ac108;
+	struct device_node *np = i2c->dev.of_node;
+	const char *regulator_name = NULL;
+	int ret = 0;
+	
+	ac108 = devm_kzalloc(&i2c->dev, sizeof(struct ac108_priv), GFP_KERNEL);
+	if (ac108 == NULL) {
+		dev_err(&i2c->dev, "Unable to allocate ac108 private data\n");
+		return -ENOMEM;
+	}
+	
+	ac108->i2c = i2c;
+	dev_set_drvdata(&i2c->dev, ac108);
+
+#if AC108_MATCH_DTS_EN
+	if (!regulator_en) {
+		ret = of_property_read_string(np, AC108_REGULATOR_NAME, &regulator_name);//(const char**)
+		if (ret) {
+			pr_err("get ac108 regulator name failed \n");
+		} else {
+			ac108->vol_supply.vcc3v3 = regulator_get(NULL, regulator_name);
+			if (IS_ERR(ac108->vol_supply.vcc3v3) || !ac108->vol_supply.vcc3v3) {
+				pr_err("get ac108 audio-3v3 failed, return!\n");
+				return -EFAULT;
+			}
+			regulator_set_voltage(ac108->vol_supply.vcc3v3, 3300000, 3300000);
+			ret = regulator_enable(ac108->vol_supply.vcc3v3);
+			if(ret != 0)
+				pr_err("[AC108] %s: some error happen, fail to enable regulator!\n", __func__);
+			regulator_en = 1;
+		}
+	}
+#endif
+
+	if (i2c_id->driver_data < (AC108_CHANNELS_MAX+3)/4) {
+		i2c_clt[i2c_id->driver_data] = i2c;
+		ret = snd_soc_register_codec(&i2c->dev, &ac108_soc_codec_driver, ac108_dai[i2c_id->driver_data], 1);//(struct snd_soc_dai_driver *)
+		if (ret < 0) {
+			dev_err(&i2c->dev, "Failed to register ac108 codec: %d\n", ret);
+		}
+	  #if !AC108_IDLE_RESET_EN
+		ac108_hw_init(i2c);
+	  #endif
+	} else {
+		pr_err("The wrong i2c_id number :%d\n", (int)(i2c_id->driver_data));
+	}
+
+	ret = sysfs_create_group(&i2c->dev.kobj, &ac108_debug_attr_group);
+	if (ret) {
+		pr_err("failed to create attr group\n");
+	}
+
+	return ret;
+}
+
+static int ac108_i2c_remove(struct i2c_client *i2c)
+{
+	//sysfs_remove_group(&i2c->dev.kobj, &ac108_debug_attr_group);
+	snd_soc_unregister_codec(&i2c->dev);
+	return 0;
+}
+
+#if AC108_MATCH_DTS_EN
+
+static const struct i2c_device_id ac108_i2c_id[] = {
+#if AC108_CHANNELS_MAX > 0
+	{ "MicArray_0", 0 },//ac108_0
+#endif
+
+#if AC108_CHANNELS_MAX > 4
+	{ "MicArray_1", 1 },//ac108_1
+#endif
+
+#if AC108_CHANNELS_MAX > 8
+	{ "MicArray_2", 2 },//ac108_2
+#endif
+
+#if AC108_CHANNELS_MAX > 12
+	{ "MicArray_3", 3 },//ac108_3
+#endif
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ac108_i2c_id);
+
+static const struct of_device_id ac108_dt_ids[] = {
+#if AC108_CHANNELS_MAX > 0
+	{ .compatible = "MicArray_0", },//ac108_0
+#endif
+
+#if AC108_CHANNELS_MAX > 4
+	{ .compatible = "MicArray_1", },//ac108_1
+#endif
+
+#if AC108_CHANNELS_MAX > 8
+	{ .compatible = "MicArray_2", },//ac108_2
+#endif
+
+#if AC108_CHANNELS_MAX > 12
+	{ .compatible = "MicArray_3", },//ac108_3
+#endif
+};
+MODULE_DEVICE_TABLE(of, ac108_dt_ids);
+
+#else
+
+
+static int ac108_i2c_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	if (adapter->nr == AC108_I2C_BUS_NUM) {
+		if(client->addr == 0x3b) {
+			strlcpy(info->type, "MicArray_0", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x35) {
+			strlcpy(info->type, "MicArray_1", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x3c) {
+			strlcpy(info->type, "MicArray_2", I2C_NAME_SIZE);
+			return 0;
+		} else if (client->addr == 0x36) {
+			strlcpy(info->type, "MicArray_3", I2C_NAME_SIZE);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static const unsigned short ac108_i2c_addr[] = {
+#if AC108_CHANNELS_MAX > 0
+	0x3b,
+#endif
+
+#if AC108_CHANNELS_MAX > 4
+	0x35,
+#endif
+
+#if AC108_CHANNELS_MAX > 8
+	0x3c,
+#endif
+
+#if AC108_CHANNELS_MAX > 12
+	0x36,
+#endif
+
+	I2C_CLIENT_END,
+};
+
+
+
+
+//device tree source or i2c_board_info both use to transfer hardware information to linux kernel, use one of them wil be OK
+static struct i2c_board_info ac108_i2c_board_info[] = {
+#if AC108_CHANNELS_MAX > 0
+	{I2C_BOARD_INFO("MicArray_0", 0x3b),},//ac108_0
+#endif
+
+#if AC108_CHANNELS_MAX > 4
+	{I2C_BOARD_INFO("MicArray_1", 0x35),},//ac108_1
+#endif
+
+#if AC108_CHANNELS_MAX > 8
+	{I2C_BOARD_INFO("MicArray_2", 0x3c),},//ac108_2
+#endif
+
+#if AC108_CHANNELS_MAX > 12
+	{I2C_BOARD_INFO("MicArray_3", 0x36),},//ac108_3
+#endif
+};
+
+#endif
+
+static struct i2c_driver ac108_i2c_driver = {
+	.class = I2C_CLASS_HWMON,
+	.driver = {
+		.name = "ac108",
+		.owner = THIS_MODULE,
+#if AC108_MATCH_DTS_EN
+		.of_match_table = ac108_dt_ids,
+#endif
+	},
+	.probe = ac108_i2c_probe,
+	.remove = ac108_i2c_remove,
+	.id_table = ac108_i2c_id,
+#if !AC108_MATCH_DTS_EN
+	.address_list = ac108_i2c_addr,
+	.detect = ac108_i2c_detect,
+#endif
+};
+
+static int __init ac108_init(void)
+{
+	int ret ;
+	ret = i2c_add_driver(&ac108_i2c_driver);
+	if (ret != 0)
+		pr_err("Failed to register ac108 i2c driver : %d \n", ret);
+	return ret;
+
+}
+module_init(ac108_init);
+
+static void __exit ac108_exit(void)
+{
+	i2c_del_driver(&ac108_i2c_driver);
+}
+module_exit(ac108_exit);
+
+MODULE_DESCRIPTION("ASoC ac108 codec driver");
+MODULE_AUTHOR("panjunwen");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/codecs/ac108.h b/sound/soc/codecs/ac108.h
index d40edfc..dc935f7 100755
--- a/sound/soc/codecs/ac108.h
+++ b/sound/soc/codecs/ac108.h
@@ -1,774 +1,810 @@
-/*
- * ac108.h --  ac108 ALSA Soc Audio driver
- *
- * Author: panjunwen
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- */
-
-#ifndef _AC108_H
-#define _AC108_H
-
-
-/*** AC108 Codec Register Define***/
-
-//Chip Reset
-#define CHIP_RST			0x00
-#define CHIP_RST_VAL		0x12
-
-//Power Control
-#define PWR_CTRL1			0x01
-#define PWR_CTRL2			0x02
-#define PWR_CTRL3			0x03
-#define PWR_CTRL4			0x04
-#define PWR_CTRL5			0x05
-#define PWR_CTRL6			0x06
-#define PWR_CTRL7			0x07
-#define PWR_CTRL8			0x08
-#define PWR_CTRL9			0x09
-
-//PLL Configure Control
-#define PLL_CTRL1			0x10
-#define PLL_CTRL2			0x11
-#define PLL_CTRL3			0x12
-#define PLL_CTRL4			0x13
-#define PLL_CTRL5			0x14
-#define PLL_CTRL6			0x16
-#define PLL_CTRL7			0x17
-#define PLL_LOCK_CTRL		0x18
-
-//System Clock Control
-#define SYSCLK_CTRL			0x20
-#define MOD_CLK_EN			0x21
-#define MOD_RST_CTRL		0x22
-#define DSM_CLK_CTRL		0x25
-
-//I2S Common Control
-#define I2S_CTRL			0x30
-#define I2S_BCLK_CTRL		0x31
-#define I2S_LRCK_CTRL1		0x32
-#define I2S_LRCK_CTRL2		0x33
-#define I2S_FMT_CTRL1		0x34
-#define I2S_FMT_CTRL2		0x35
-#define I2S_FMT_CTRL3		0x36
-
-//I2S TX1 Control
-#define I2S_TX1_CTRL1		0x38
-#define I2S_TX1_CTRL2		0x39
-#define I2S_TX1_CTRL3		0x3A
-#define I2S_TX1_CHMP_CTRL1	0x3C
-#define I2S_TX1_CHMP_CTRL2	0x3D
-#define I2S_TX1_CHMP_CTRL3	0x3E
-#define I2S_TX1_CHMP_CTRL4	0x3F
-
-//I2S TX2 Control
-#define I2S_TX2_CTRL1		0x40
-#define I2S_TX2_CTRL2		0x41
-#define I2S_TX2_CTRL3		0x42
-#define I2S_TX2_CHMP_CTRL1	0x44
-#define I2S_TX2_CHMP_CTRL2	0x45
-#define I2S_TX2_CHMP_CTRL3	0x46
-#define I2S_TX2_CHMP_CTRL4	0x47
-
-//I2S RX1 Control
-#define I2S_RX1_CTRL1		0x50
-#define I2S_RX1_CHMP_CTRL1	0x54
-#define I2S_RX1_CHMP_CTRL2	0x55
-#define I2S_RX1_CHMP_CTRL3	0x56
-#define I2S_RX1_CHMP_CTRL4	0x57
-
-//I2S Loopback Debug
-#define I2S_LPB_DEBUG		0x58
-
-//ADC Common Control
-#define ADC_SPRC			0x60
-#define ADC_DIG_EN			0x61
-#define DMIC_EN				0x62
-#define ADC_DSR				0x63
-#define ADC_FIR				0x64
-#define ADC_DDT_CTRL		0x65
-
-//HPF Control
-#define HPF_EN				0x66
-#define HPF_COEF_REGH1		0x67
-#define HPF_COEF_REGH2		0x68
-#define HPF_COEF_REGL1		0x69
-#define HPF_COEF_REGL2		0x6A
-#define HPF_GAIN_REGH1		0x6B
-#define HPF_GAIN_REGH2		0x6C
-#define HPF_GAIN_REGL1		0x6D
-#define HPF_GAIN_REGL2		0x6E
-
-//ADC Digital Channel Volume Control
-#define ADC1_DVOL_CTRL		0x70
-#define ADC2_DVOL_CTRL		0x71
-#define ADC3_DVOL_CTRL		0x72
-#define ADC4_DVOL_CTRL		0x73
-
-//ADC Digital Mixer Source and Gain Control
-#define ADC1_DMIX_SRC		0x76
-#define ADC2_DMIX_SRC		0x77
-#define ADC3_DMIX_SRC		0x78
-#define ADC4_DMIX_SRC		0x79
-
-//ADC Digital Debug Control
-#define ADC_DIG_DEBUG		0x7F
-
-//I2S Pad Drive Control
-#define I2S_DAT_PADDRV_CTRL	0x80
-#define I2S_CLK_PADDRV_CTRL	0x81
-
-//Analog PGA Control
-#define ANA_PGA1_CTRL		0x90
-#define ANA_PGA2_CTRL		0x91
-#define ANA_PGA3_CTRL		0x92
-#define ANA_PGA4_CTRL		0x93
-
-//MIC Offset Control
-#define MIC_OFFSET_CTRL1	0x96
-#define MIC_OFFSET_CTRL2	0x97
-#define MIC1_OFFSET_STATU1	0x98
-#define MIC1_OFFSET_STATU2	0x99
-#define MIC2_OFFSET_STATU1	0x9A
-#define MIC2_OFFSET_STATU2	0x9B
-#define MIC3_OFFSET_STATU1	0x9C
-#define MIC3_OFFSET_STATU2	0x9D
-#define MIC4_OFFSET_STATU1	0x9E
-#define MIC4_OFFSET_STATU2	0x9F
-
-//ADC1 Analog Control
-#define ANA_ADC1_CTRL1		0xA0
-#define ANA_ADC1_CTRL2		0xA1
-#define ANA_ADC1_CTRL3		0xA2
-#define ANA_ADC1_CTRL4		0xA3
-#define ANA_ADC1_CTRL5		0xA4
-#define ANA_ADC1_CTRL6		0xA5
-#define ANA_ADC1_CTRL7		0xA6
-
-//ADC2 Analog Control
-#define ANA_ADC2_CTRL1		0xA7
-#define ANA_ADC2_CTRL2		0xA8
-#define ANA_ADC2_CTRL3		0xA9
-#define ANA_ADC2_CTRL4		0xAA
-#define ANA_ADC2_CTRL5		0xAB
-#define ANA_ADC2_CTRL6		0xAC
-#define ANA_ADC2_CTRL7		0xAD
-
-//ADC3 Analog Control
-#define ANA_ADC3_CTRL1		0xAE
-#define ANA_ADC3_CTRL2		0xAF
-#define ANA_ADC3_CTRL3		0xB0
-#define ANA_ADC3_CTRL4		0xB1
-#define ANA_ADC3_CTRL5		0xB2
-#define ANA_ADC3_CTRL6		0xB3
-#define ANA_ADC3_CTRL7		0xB4
-
-//ADC4 Analog Control
-#define ANA_ADC4_CTRL1		0xB5
-#define ANA_ADC4_CTRL2		0xB6
-#define ANA_ADC4_CTRL3		0xB7
-#define ANA_ADC4_CTRL4		0xB8
-#define ANA_ADC4_CTRL5		0xB9
-#define ANA_ADC4_CTRL6		0xBA
-#define ANA_ADC4_CTRL7		0xBB
-
-//GPIO Configure
-#define GPIO_CFG1			0xC0
-#define GPIO_CFG2			0xC1
-#define GPIO_DAT			0xC2
-#define GPIO_DRV			0xC3
-#define GPIO_PULL			0xC4
-#define GPIO_INT_CFG		0xC5
-#define GPIO_INT_EN			0xC6
-#define GPIO_INT_STATUS		0xC7
-
-//Misc
-#define BGTC_DAT			0xD1
-#define BGVC_DAT			0xD2
-#define PRNG_CLK_CTRL		0xDF
-
-
-
-/*** AC108 Codec Register Bit Define***/
-
-/*PWR_CTRL1*/
-#define CP12_CTRL				4
-#define CP12_SENSE_SELECT		3
-
-/*PWR_CTRL2*/
-#define CP12_SENSE_FILT			6
-#define CP12_COMP_FF_EN			3
-#define CP12_FORCE_ENABLE		2
-#define CP12_FORCE_RSTB			1
-
-/*PWR_CTRL3*/
-#define LDO33DIG_CTRL			0
-
-/*PWR_CTRL6*/
-#define LDO33ANA_2XHDRM			2
-#define LDO33ANA_ENABLE			0
-
-/*PWR_CTRL7*/
-#define VREF_SEL				3
-#define VREF_FASTSTART_ENABLE	1
-#define VREF_ENABLE				0
-
-/*PWR_CTRL9*/
-#define VREFP_FASTSTART_ENABLE	7
-#define VREFP_RESCTRL			5
-#define VREFP_LPMODE			4
-#define IGEN_TRIM				1
-#define VREFP_ENABLE			0
-
-
-/*PLL_CTRL1*/
-#define PLL_IBIAS				4
-#define PLL_NDET				3
-#define PLL_LOCKED_STATUS		2
-#define PLL_COM_EN				1
-#define PLL_EN					0
-
-/*PLL_CTRL2*/
-#define PLL_PREDIV2				5
-#define PLL_PREDIV1				0
-
-/*PLL_CTRL3*/
-#define PLL_LOOPDIV_MSB			0
-
-/*PLL_CTRL4*/
-#define PLL_LOOPDIV_LSB			0
-
-/*PLL_CTRL5*/
-#define PLL_POSTDIV2			5
-#define PLL_POSTDIV1			0
-
-/*PLL_CTRL6*/
-#define PLL_LDO					6
-#define PLL_CP					0
-
-/*PLL_CTRL7*/
-#define PLL_CAP					6
-#define PLL_RES					4
-#define PLL_TEST_EN				0
-
-/*PLL_LOCK_CTRL*/
-#define LOCK_LEVEL1				2
-#define LOCK_LEVEL2				1
-#define PLL_LOCK_EN				0
-
-
-/*SYSCLK_CTRL*/
-#define PLLCLK_EN				7
-#define PLLCLK_SRC				4
-#define SYSCLK_SRC				3
-#define SYSCLK_EN				0
-
-/*MOD_CLK_EN & MOD_RST_CTRL*/
-#define I2S						7
-#define ADC_DIGITAL				4
-#define MIC_OFFSET_CALIBRATION	1
-#define ADC_ANALOG				0
-
-/*DSM_CLK_CTRL*/
-#define MIC_OFFSET_DIV			4
-#define DSM_CLK_SEL				0
-
-
-/*I2S_CTRL*/
-#define BCLK_IOEN				7
-#define LRCK_IOEN				6
-#define SDO2_EN					5
-#define SDO1_EN					4
-#define TXEN					2
-#define RXEN					1
-#define GEN						0
-
-/*I2S_BCLK_CTRL*/
-#define EDGE_TRANSFER			5
-#define BCLK_POLARITY			4
-#define BCLKDIV					0
-
-/*I2S_LRCK_CTRL1*/
-#define LRCK_POLARITY			4
-#define LRCK_PERIODH			0
-
-/*I2S_LRCK_CTRL2*/
-#define LRCK_PERIODL			0
-
-/*I2S_FMT_CTRL1*/
-#define ENCD_SEL				6
-#define MODE_SEL				4
-#define TX2_OFFSET				3
-#define TX1_OFFSET				2
-#define TX_SLOT_HIZ				1
-#define TX_STATE				0
-
-/*I2S_FMT_CTRL2*/
-#define SLOT_WIDTH_SEL			4
-#define SAMPLE_RESOLUTION		0
-
-/*I2S_FMT_CTRL3*/
-#define TX_MLS					7
-#define SEXT					5
-#define OUT2_MUTE				4
-#define OUT1_MUTE				3
-#define LRCK_WIDTH				2
-#define TX_PDM					0
-
-
-/*I2S_TX1_CTRL1*/
-#define TX1_CHSEL				0
-
-/*I2S_TX1_CTRL2*/
-#define TX1_CH8_EN				7
-#define TX1_CH7_EN				6
-#define TX1_CH6_EN				5
-#define TX1_CH5_EN				4
-#define TX1_CH4_EN				3
-#define TX1_CH3_EN				2
-#define TX1_CH2_EN				1
-#define TX1_CH1_EN				0
-
-/*I2S_TX1_CTRL3*/
-#define TX1_CH16_EN				7
-#define TX1_CH15_EN				6
-#define TX1_CH14_EN				5
-#define TX1_CH13_EN				4
-#define TX1_CH12_EN				3
-#define TX1_CH11_EN				2
-#define TX1_CH10_EN				1
-#define TX1_CH9_EN				0
-
-/*I2S_TX1_CHMP_CTRL1*/
-#define TX1_CH4_MAP				6
-#define TX1_CH3_MAP				4
-#define TX1_CH2_MAP				2
-#define TX1_CH1_MAP				0
-
-/*I2S_TX1_CHMP_CTRL2*/
-#define TX1_CH8_MAP				6
-#define TX1_CH7_MAP				4
-#define TX1_CH6_MAP				2
-#define TX1_CH5_MAP				0
-
-/*I2S_TX1_CHMP_CTRL3*/
-#define TX1_CH12_MAP			6
-#define TX1_CH11_MAP			4
-#define TX1_CH10_MAP			2
-#define TX1_CH9_MAP				0
-
-/*I2S_TX1_CHMP_CTRL4*/
-#define TX1_CH16_MAP			6
-#define TX1_CH15_MAP			4
-#define TX1_CH14_MAP			2
-#define TX1_CH13_MAP			0
-
-
-/*I2S_TX2_CTRL1*/
-#define TX2_CHSEL				0
-
-/*I2S_TX2_CHMP_CTRL1*/
-#define TX2_CH4_MAP				6
-#define TX2_CH3_MAP				4
-#define TX2_CH2_MAP				2
-#define TX2_CH1_MAP				0
-
-/*I2S_TX2_CHMP_CTRL2*/
-#define TX2_CH8_MAP				6
-#define TX2_CH7_MAP				4
-#define TX2_CH6_MAP				2
-#define TX2_CH5_MAP				0
-
-/*I2S_TX2_CHMP_CTRL3*/
-#define TX2_CH12_MAP			6
-#define TX2_CH11_MAP			4
-#define TX2_CH10_MAP			2
-#define TX2_CH9_MAP				0
-
-/*I2S_TX2_CHMP_CTRL4*/
-#define TX2_CH16_MAP			6
-#define TX2_CH15_MAP			4
-#define TX2_CH14_MAP			2
-#define TX2_CH13_MAP			0
-
-
-/*I2S_RX1_CTRL1*/
-#define RX1_CHSEL				0
-
-/*I2S_RX1_CHMP_CTRL1*/
-#define RX1_CH4_MAP				6
-#define RX1_CH3_MAP				4
-#define RX1_CH2_MAP				2
-#define RX1_CH1_MAP				0
-
-/*I2S_RX1_CHMP_CTRL2*/
-#define RX1_CH8_MAP				6
-#define RX1_CH7_MAP				4
-#define RX1_CH6_MAP				2
-#define RX1_CH5_MAP				0
-
-/*I2S_RX1_CHMP_CTRL3*/
-#define RX1_CH12_MAP			6
-#define RX1_CH11_MAP			4
-#define RX1_CH10_MAP			2
-#define RX1_CH9_MAP				0
-
-/*I2S_RX1_CHMP_CTRL4*/
-#define RX1_CH16_MAP			6
-#define RX1_CH15_MAP			4
-#define RX1_CH14_MAP			2
-#define RX1_CH13_MAP			0
-
-
-/*I2S_LPB_DEBUG*/
-#define I2S_LPB_DEBUG_EN		0
-
-
-/*ADC_SPRC*/
-#define ADC_FS_I2S1				0
-
-/*ADC_DIG_EN*/
-#define DG_EN					4
-#define ENAD4					3
-#define ENAD3					2
-#define ENAD2					1
-#define ENAD1					0
-
-/*DMIC_EN*/
-#define DMIC2_EN				1
-#define DMIC1_EN				0
-
-/*ADC_DSR*/
-#define DIG_ADC4_SRS			6
-#define DIG_ADC3_SRS			4
-#define DIG_ADC2_SRS			2
-#define DIG_ADC1_SRS			0
-
-/*ADC_DDT_CTRL*/
-#define ADOUT_DLY_EN			2
-#define ADOUT_DTS				0
-
-
-/*HPF_EN*/
-#define DIG_ADC4_HPF_EN			3
-#define DIG_ADC3_HPF_EN			2
-#define DIG_ADC2_HPF_EN			1
-#define DIG_ADC1_HPF_EN			0
-
-
-/*ADC1_DMIX_SRC*/
-#define ADC1_ADC4_DMXL_GC		7
-#define ADC1_ADC3_DMXL_GC		6
-#define ADC1_ADC2_DMXL_GC		5
-#define ADC1_ADC1_DMXL_GC		4
-#define ADC1_ADC4_DMXL_SRC		3
-#define ADC1_ADC3_DMXL_SRC		2
-#define ADC1_ADC2_DMXL_SRC		1
-#define ADC1_ADC1_DMXL_SRC		0
-
-/*ADC2_DMIX_SRC*/
-#define ADC2_ADC4_DMXL_GC		7
-#define ADC2_ADC3_DMXL_GC		6
-#define ADC2_ADC2_DMXL_GC		5
-#define ADC2_ADC1_DMXL_GC		4
-#define ADC2_ADC4_DMXL_SRC		3
-#define ADC2_ADC3_DMXL_SRC		2
-#define ADC2_ADC2_DMXL_SRC		1
-#define ADC2_ADC1_DMXL_SRC		0
-
-/*ADC3_DMIX_SRC*/
-#define ADC3_ADC4_DMXL_GC		7
-#define ADC3_ADC3_DMXL_GC		6
-#define ADC3_ADC2_DMXL_GC		5
-#define ADC3_ADC1_DMXL_GC		4
-#define ADC3_ADC4_DMXL_SRC		3
-#define ADC3_ADC3_DMXL_SRC		2
-#define ADC3_ADC2_DMXL_SRC		1
-#define ADC3_ADC1_DMXL_SRC		0
-
-/*ADC4_DMIX_SRC*/
-#define ADC4_ADC4_DMXL_GC		7
-#define ADC4_ADC3_DMXL_GC		6
-#define ADC4_ADC2_DMXL_GC		5
-#define ADC4_ADC1_DMXL_GC		4
-#define ADC4_ADC4_DMXL_SRC		3
-#define ADC4_ADC3_DMXL_SRC		2
-#define ADC4_ADC2_DMXL_SRC		1
-#define ADC4_ADC1_DMXL_SRC		0
-
-
-/*ADC_DIG_DEBUG*/
-#define ADC_PTN_SEL				0
-
-
-/*I2S_DAT_PADDRV_CTRL*/
-#define TX2_DAT_DRV				4
-#define TX1_DAT_DRV				0
-
-/*I2S_CLK_PADDRV_CTRL*/
-#define LRCK_DRV				4
-#define BCLK_DRV				0
-
-
-/*ANA_PGA1_CTRL*/
-#define ADC1_ANALOG_PGA			1
-#define ADC1_ANALOG_PGA_STEP	0
-
-/*ANA_PGA2_CTRL*/
-#define ADC2_ANALOG_PGA			1
-#define ADC2_ANALOG_PGA_STEP	0
-
-/*ANA_PGA3_CTRL*/
-#define ADC3_ANALOG_PGA			1
-#define ADC3_ANALOG_PGA_STEP	0
-
-/*ANA_PGA4_CTRL*/
-#define ADC4_ANALOG_PGA			1
-#define ADC4_ANALOG_PGA_STEP	0
-
-
-/*MIC_OFFSET_CTRL1*/
-#define MIC_OFFSET_CAL_EN4		3
-#define MIC_OFFSET_CAL_EN3		2
-#define MIC_OFFSET_CAL_EN2		1
-#define MIC_OFFSET_CAL_EN1		0
-
-/*MIC_OFFSET_CTRL2*/
-#define MIC_OFFSET_CAL_GAIN		3
-#define MIC_OFFSET_CAL_CHANNEL	1
-#define MIC_OFFSET_CAL_EN_ONCE	0
-
-/*MIC1_OFFSET_STATU1*/
-#define MIC1_OFFSET_CAL_DONE	7
-#define MIC1_OFFSET_CAL_RUN_STA	6
-#define MIC1_OFFSET_MSB			0
-
-/*MIC1_OFFSET_STATU2*/
-#define MIC1_OFFSET_LSB			0
-
-/*MIC2_OFFSET_STATU1*/
-#define MIC2_OFFSET_CAL_DONE	7
-#define MIC2_OFFSET_CAL_RUN_STA	6
-#define MIC2_OFFSET_MSB			0
-
-/*MIC2_OFFSET_STATU2*/
-#define MIC2_OFFSET_LSB			0
-
-/*MIC3_OFFSET_STATU1*/
-#define MIC3_OFFSET_CAL_DONE	7
-#define MIC3_OFFSET_CAL_RUN_STA	6
-#define MIC3_OFFSET_MSB			0
-
-/*MIC3_OFFSET_STATU2*/
-#define MIC3_OFFSET_LSB			0
-
-/*MIC4_OFFSET_STATU1*/
-#define MIC4_OFFSET_CAL_DONE	7
-#define MIC4_OFFSET_CAL_RUN_STA	6
-#define MIC4_OFFSET_MSB			0
-
-/*MIC4_OFFSET_STATU2*/
-#define MIC4_OFFSET_LSB			0
-
-
-/*ANA_ADC1_CTRL1*/
-#define ADC1_PGA_BYPASS			7
-#define ADC1_PGA_BYP_RCM		6
-#define ADC1_PGA_CTRL_RCM		4
-#define ADC1_PGA_MUTE			3
-#define ADC1_DSM_ENABLE			2
-#define ADC1_PGA_ENABLE			1
-#define ADC1_MICBIAS_EN			0
-
-/*ANA_ADC1_CTRL3*/
-#define ADC1_ANA_CAL_EN			5
-#define ADC1_SEL_OUT_EDGE		3
-#define ADC1_DSM_DISABLE		2
-#define ADC1_VREFP_DISABLE		1
-#define ADC1_AAF_DISABLE		0
-
-/*ANA_ADC1_CTRL6*/
-#define PGA_CTRL_TC				6
-#define PGA_CTRL_RC				4
-#define PGA_CTRL_I_LIN			2
-#define PGA_CTRL_I_IN			0
-
-/*ANA_ADC1_CTRL7*/
-#define PGA_CTRL_HI_Z			7
-#define PGA_CTRL_SHORT_RF		6
-#define PGA_CTRL_VCM_VG			4
-#define PGA_CTRL_VCM_IN			0
-
-
-/*ANA_ADC2_CTRL1*/
-#define ADC2_PGA_BYPASS			7
-#define ADC2_PGA_BYP_RCM		6
-#define ADC2_PGA_CTRL_RCM		4
-#define ADC2_PGA_MUTE			3
-#define ADC2_DSM_ENABLE			2
-#define ADC2_PGA_ENABLE			1
-#define ADC2_MICBIAS_EN			0
-
-/*ANA_ADC2_CTRL3*/
-#define ADC2_ANA_CAL_EN			5
-#define ADC2_SEL_OUT_EDGE		3
-#define ADC2_DSM_DISABLE		2
-#define ADC2_VREFP_DISABLE		1
-#define ADC2_AAF_DISABLE		0
-
-/*ANA_ADC2_CTRL6*/
-#define PGA_CTRL_IBOOST			7
-#define PGA_CTRL_IQCTRL			6
-#define PGA_CTRL_OABIAS			4
-#define PGA_CTRL_CMLP_DIS		3
-#define PGA_CTRL_PDB_RIN		2
-#define PGA_CTRL_PEAKDET		0
-
-/*ANA_ADC2_CTRL7*/
-#define AAF_LPMODE_EN			7
-#define AAF_STG2_IB_SEL			4
-#define AAFDSM_IB_DIV2			3
-#define AAF_STG1_IB_SEL			0
-
-
-/*ANA_ADC3_CTRL1*/
-#define ADC3_PGA_BYPASS			7
-#define ADC3_PGA_BYP_RCM		6
-#define ADC3_PGA_CTRL_RCM		4
-#define ADC3_PGA_MUTE			3
-#define ADC3_DSM_ENABLE			2
-#define ADC3_PGA_ENABLE			1
-#define ADC3_MICBIAS_EN			0
-
-/*ANA_ADC3_CTRL3*/
-#define ADC3_ANA_CAL_EN			5
-#define ADC3_INVERT_CLK			4
-#define ADC3_SEL_OUT_EDGE		3
-#define ADC3_DSM_DISABLE		2
-#define ADC3_VREFP_DISABLE		1
-#define ADC3_AAF_DISABLE		0
-
-/*ANA_ADC3_CTRL7*/
-#define DSM_COMP_IB_SEL			6
-#define DSM_OTA_CTRL			4
-#define DSM_LPMODE				3
-#define DSM_OTA_IB_SEL			0
-
-
-/*ANA_ADC4_CTRL1*/
-#define ADC4_PGA_BYPASS			7
-#define ADC4_PGA_BYP_RCM		6
-#define ADC4_PGA_CTRL_RCM		4
-#define ADC4_PGA_MUTE			3
-#define ADC4_DSM_ENABLE			2
-#define ADC4_PGA_ENABLE			1
-#define ADC4_MICBIAS_EN			0
-
-/*ANA_ADC4_CTRL3*/
-#define ADC4_ANA_CAL_EN			5
-#define ADC4_SEL_OUT_EDGE		3
-#define ADC4_DSM_DISABLE		2
-#define ADC4_VREFP_DISABLE		1
-#define ADC4_AAF_DISABLE		0
-
-/*ANA_ADC4_CTRL6*/
-#define DSM_DEMOFF				5
-#define DSM_EN_DITHER			4
-#define DSM_VREFP_LPMODE		2
-#define DSM_VREFP_OUTCTRL		0
-
-/*ANA_ADC4_CTRL7*/
-#define CK8M_EN					5
-#define OSC_EN					4
-#define ADC4_CLK_GATING			3
-#define ADC3_CLK_GATING			2
-#define ADC2_CLK_GATING			1
-#define ADC1_CLK_GATING			0
-
-
-/*GPIO_CFG1*/
-#define GPIO2_SELECT			4
-#define GPIO1_SELECT			0
-
-/*GPIO_CFG2*/
-#define GPIO4_SELECT			4
-#define GPIO3_SELECT			0
-
-/*GPIO_DAT*///order???
-#define GPIO4_DAT				3
-#define GPIO3_DAT				2
-#define GPIO2_DAT				1
-#define GPIO1_DAT				0
-
-/*GPIO_DRV*/
-#define GPIO4_DRV				6
-#define GPIO3_DRV				4
-#define GPIO2_DRV				2
-#define GPIO1_DRV				0
-
-/*GPIO_PULL*/
-#define GPIO4_PULL				6
-#define GPIO3_PULL				4
-#define GPIO2_PULL				2
-#define GPIO1_PULL				0
-
-/*GPIO_INT_CFG*/
-#define GPIO4_EINT_CFG			6
-#define GPIO3_EINT_CFG			4
-#define GPIO2_EINT_CFG			2
-#define GPIO1_EINT_CFG			0
-
-/*GPIO_INT_EN*///order???
-#define GPIO4_EINT_EN			3
-#define GPIO3_EINT_EN			2
-#define GPIO2_EINT_EN			1
-#define GPIO1_EINT_EN			0
-
-/*GPIO_INT_STATUS*///order???
-#define GPIO4_EINT_STA			3
-#define GPIO3_EINT_STA			2
-#define GPIO2_EINT_STA			1
-#define GPIO1_EINT_STA			0
-
-
-/*PRNG_CLK_CTRL*/
-#define PRNG_CLK_EN				1
-#define PRNG_CLK_POS			0
-
-
-
-/*** Some Config Value ***/
-
-//[SYSCLK_CTRL]: PLLCLK_SRC
-#define PLLCLK_SRC_MCLK			0
-#define PLLCLK_SRC_BCLK			1
-#define PLLCLK_SRC_GPIO2		2
-#define PLLCLK_SRC_GPIO3		3
-
-//[SYSCLK_CTRL]: SYSCLK_SRC
-#define SYSCLK_SRC_MCLK			0
-#define SYSCLK_SRC_PLL			1
-
-//I2S BCLK POLARITY Control
-#define BCLK_NORMAL_DRIVE_N_SAMPLE_P	0
-#define BCLK_INVERT_DRIVE_P_SAMPLE_N	1
-
-//I2S LRCK POLARITY Control
-#define	LRCK_LEFT_LOW_RIGHT_HIGH		0
-#define LRCK_LEFT_HIGH_RIGHT_LOW		1
-
-//I2S Format Selection
-#define PCM_FORMAT						0
-#define LEFT_JUSTIFIED_FORMAT			1
-#define RIGHT_JUSTIFIED_FORMAT			2
-
-
-//I2S data protocol types
-
-#define IS_ENCODING_MODE		 0
-
-#endif
-
+/*
+ * ac108.h --  ac108 ALSA Soc Audio driver
+ *
+ * Version: 2.0
+ *
+ * Author: panjunwen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _AC108_H
+#define _AC108_H
+
+
+/*** AC108 Codec Register Define***/
+
+//Chip Reset
+#define CHIP_AUDIO_RST		0x00
+
+//Power Control
+#define PWR_CTRL1			0x01
+#define PWR_CTRL2			0x02
+#define PWR_CTRL3			0x03
+#define PWR_CTRL4			0x04
+#define PWR_CTRL5			0x05
+#define PWR_CTRL6			0x06
+#define PWR_CTRL7			0x07
+#define PWR_CTRL8			0x08
+#define PWR_CTRL9			0x09
+
+//PLL Configure Control
+#define PLL_CTRL1			0x10
+#define PLL_CTRL2			0x11
+#define PLL_CTRL3			0x12
+#define PLL_CTRL4			0x13
+#define PLL_CTRL5			0x14
+#define PLL_CTRL6			0x16
+#define PLL_CTRL7			0x17
+#define PLL_LOCK_CTRL		0x18
+
+//System Clock Control
+#define SYSCLK_CTRL			0x20
+#define MOD_CLK_EN			0x21
+#define MOD_RST_CTRL		0x22
+#define DSM_CLK_CTRL		0x25
+
+//I2S Common Control
+#define I2S_CTRL			0x30
+#define I2S_BCLK_CTRL		0x31
+#define I2S_LRCK_CTRL1		0x32
+#define I2S_LRCK_CTRL2		0x33
+#define I2S_FMT_CTRL1		0x34
+#define I2S_FMT_CTRL2		0x35
+#define I2S_FMT_CTRL3		0x36
+
+//I2S TX1 Control
+#define I2S_TX1_CTRL1		0x38
+#define I2S_TX1_CTRL2		0x39
+#define I2S_TX1_CTRL3		0x3A
+#define I2S_TX1_CHMP_CTRL1	0x3C
+#define I2S_TX1_CHMP_CTRL2	0x3D
+#define I2S_TX1_CHMP_CTRL3	0x3E
+#define I2S_TX1_CHMP_CTRL4	0x3F
+
+//I2S TX2 Control
+#define I2S_TX2_CTRL1		0x40
+#define I2S_TX2_CTRL2		0x41
+#define I2S_TX2_CTRL3		0x42
+#define I2S_TX2_CHMP_CTRL1	0x44
+#define I2S_TX2_CHMP_CTRL2	0x45
+#define I2S_TX2_CHMP_CTRL3	0x46
+#define I2S_TX2_CHMP_CTRL4	0x47
+
+//I2S RX1 Control
+#define I2S_RX1_CTRL1		0x50
+#define I2S_RX1_CHMP_CTRL1	0x54
+#define I2S_RX1_CHMP_CTRL2	0x55
+#define I2S_RX1_CHMP_CTRL3	0x56
+#define I2S_RX1_CHMP_CTRL4	0x57
+
+//I2S Loopback Debug
+#define I2S_LPB_DEBUG		0x58
+
+//ADC Common Control
+#define ADC_SPRC			0x60
+#define ADC_DIG_EN			0x61
+#define DMIC_EN				0x62
+#define ADC_DSR				0x63
+#define ADC_FIR				0x64
+#define ADC_DDT_CTRL		0x65
+
+//HPF Control
+#define HPF_EN				0x66
+#define HPF_COEF_REGH1		0x67
+#define HPF_COEF_REGH2		0x68
+#define HPF_COEF_REGL1		0x69
+#define HPF_COEF_REGL2		0x6A
+#define HPF_GAIN_REGH1		0x6B
+#define HPF_GAIN_REGH2		0x6C
+#define HPF_GAIN_REGL1		0x6D
+#define HPF_GAIN_REGL2		0x6E
+
+//ADC Digital Channel Volume Control
+#define ADC1_DVOL_CTRL		0x70
+#define ADC2_DVOL_CTRL		0x71
+#define ADC3_DVOL_CTRL		0x72
+#define ADC4_DVOL_CTRL		0x73
+
+//ADC Digital Mixer Source and Gain Control
+#define ADC1_DMIX_SRC		0x76
+#define ADC2_DMIX_SRC		0x77
+#define ADC3_DMIX_SRC		0x78
+#define ADC4_DMIX_SRC		0x79
+
+//ADC Digital Debug Control
+#define ADC_DIG_DEBUG		0x7F
+
+//I2S Pad Drive Control
+#define I2S_DAT_PADDRV_CTRL	0x80
+#define I2S_CLK_PADDRV_CTRL	0x81
+
+//Analog PGA Control
+#define ANA_PGA1_CTRL		0x90
+#define ANA_PGA2_CTRL		0x91
+#define ANA_PGA3_CTRL		0x92
+#define ANA_PGA4_CTRL		0x93
+
+//MIC Offset Control
+#define MIC_OFFSET_CTRL1	0x96
+#define MIC_OFFSET_CTRL2	0x97
+#define MIC1_OFFSET_STATU1	0x98
+#define MIC1_OFFSET_STATU2	0x99
+#define MIC2_OFFSET_STATU1	0x9A
+#define MIC2_OFFSET_STATU2	0x9B
+#define MIC3_OFFSET_STATU1	0x9C
+#define MIC3_OFFSET_STATU2	0x9D
+#define MIC4_OFFSET_STATU1	0x9E
+#define MIC4_OFFSET_STATU2	0x9F
+
+//ADC1 Analog Control
+#define ANA_ADC1_CTRL1		0xA0
+#define ANA_ADC1_CTRL2		0xA1
+#define ANA_ADC1_CTRL3		0xA2
+#define ANA_ADC1_CTRL4		0xA3
+#define ANA_ADC1_CTRL5		0xA4
+#define ANA_ADC1_CTRL6		0xA5
+#define ANA_ADC1_CTRL7		0xA6
+
+//ADC2 Analog Control
+#define ANA_ADC2_CTRL1		0xA7
+#define ANA_ADC2_CTRL2		0xA8
+#define ANA_ADC2_CTRL3		0xA9
+#define ANA_ADC2_CTRL4		0xAA
+#define ANA_ADC2_CTRL5		0xAB
+#define ANA_ADC2_CTRL6		0xAC
+#define ANA_ADC2_CTRL7		0xAD
+
+//ADC3 Analog Control
+#define ANA_ADC3_CTRL1		0xAE
+#define ANA_ADC3_CTRL2		0xAF
+#define ANA_ADC3_CTRL3		0xB0
+#define ANA_ADC3_CTRL4		0xB1
+#define ANA_ADC3_CTRL5		0xB2
+#define ANA_ADC3_CTRL6		0xB3
+#define ANA_ADC3_CTRL7		0xB4
+
+//ADC4 Analog Control
+#define ANA_ADC4_CTRL1		0xB5
+#define ANA_ADC4_CTRL2		0xB6
+#define ANA_ADC4_CTRL3		0xB7
+#define ANA_ADC4_CTRL4		0xB8
+#define ANA_ADC4_CTRL5		0xB9
+#define ANA_ADC4_CTRL6		0xBA
+#define ANA_ADC4_CTRL7		0xBB
+
+//GPIO Configure
+#define GPIO_CFG1			0xC0
+#define GPIO_CFG2			0xC1
+#define GPIO_DAT			0xC2
+#define GPIO_DRV			0xC3
+#define GPIO_PULL			0xC4
+#define GPIO_INT_CFG		0xC5
+#define GPIO_INT_EN			0xC6
+#define GPIO_INT_STATUS		0xC7
+
+//Misc
+#define BGTC_DAT			0xD1
+#define BGVC_DAT			0xD2
+#define PRNG_CLK_CTRL		0xDF
+
+
+
+/*** AC108 Codec Register Bit Define***/
+
+/*PWR_CTRL1*/
+#define CP12_CTRL				4
+#define CP12_SENSE_SELECT		3
+
+/*PWR_CTRL2*/
+#define CP12_SENSE_FILT			6
+#define CP12_COMP_FF_EN			3
+#define CP12_FORCE_ENABLE		2
+#define CP12_FORCE_RSTB			1
+
+/*PWR_CTRL3*/
+#define LDO33DIG_CTRL			0
+
+/*PWR_CTRL6*/
+#define LDO33ANA_2XHDRM			2
+#define LDO33ANA_ENABLE			0
+
+/*PWR_CTRL7*/
+#define VREF_SEL				3
+#define VREF_FASTSTART_ENABLE	1
+#define VREF_ENABLE				0
+
+/*PWR_CTRL9*/
+#define VREFP_FASTSTART_ENABLE	7
+#define VREFP_RESCTRL			5
+#define VREFP_LPMODE			4
+#define IGEN_TRIM				1
+#define VREFP_ENABLE			0
+
+
+/*PLL_CTRL1*/
+#define PLL_IBIAS				4
+#define PLL_NDET				3
+#define PLL_LOCKED_STATUS		2
+#define PLL_COM_EN				1
+#define PLL_EN					0
+
+/*PLL_CTRL2*/
+#define PLL_PREDIV2				5
+#define PLL_PREDIV1				0
+
+/*PLL_CTRL3*/
+#define PLL_LOOPDIV_MSB			0
+
+/*PLL_CTRL4*/
+#define PLL_LOOPDIV_LSB			0
+
+/*PLL_CTRL5*/
+#define PLL_POSTDIV2			5
+#define PLL_POSTDIV1			0
+
+/*PLL_CTRL6*/
+#define PLL_LDO					6
+#define PLL_CP					0
+
+/*PLL_CTRL7*/
+#define PLL_CAP					6
+#define PLL_RES					4
+#define PLL_TEST_EN				0
+
+/*PLL_LOCK_CTRL*/
+#define LOCK_LEVEL1				2
+#define LOCK_LEVEL2				1
+#define PLL_LOCK_EN				0
+
+
+/*SYSCLK_CTRL*/
+#define PLLCLK_EN				7
+#define PLLCLK_SRC				4
+#define SYSCLK_SRC				3
+#define SYSCLK_EN				0
+
+/*MOD_CLK_EN & MOD_RST_CTRL*/
+#define I2S						7
+#define ADC_DIGITAL				4
+#define MIC_OFFSET_CALIBRATION	1
+#define ADC_ANALOG				0
+
+/*DSM_CLK_CTRL*/
+#define MIC_OFFSET_DIV			4
+#define DSM_CLK_SEL				0
+
+
+/*I2S_CTRL*/
+#define BCLK_IOEN				7
+#define LRCK_IOEN				6
+#define SDO2_EN					5
+#define SDO1_EN					4
+#define TXEN					2
+#define RXEN					1
+#define GEN						0
+
+/*I2S_BCLK_CTRL*/
+#define EDGE_TRANSFER			5
+#define BCLK_POLARITY			4
+#define BCLKDIV					0
+
+/*I2S_LRCK_CTRL1*/
+#define LRCK_POLARITY			4
+#define LRCK_PERIODH			0
+
+/*I2S_LRCK_CTRL2*/
+#define LRCK_PERIODL			0
+
+/*I2S_FMT_CTRL1*/
+#define ENCD_SEL				6
+#define MODE_SEL				4
+#define TX2_OFFSET				3
+#define TX1_OFFSET				2
+#define TX_SLOT_HIZ				1
+#define TX_STATE				0
+
+/*I2S_FMT_CTRL2*/
+#define SLOT_WIDTH_SEL			4
+#define SAMPLE_RESOLUTION		0
+
+/*I2S_FMT_CTRL3*/
+#define TX_MLS					7
+#define SEXT					5
+#define OUT2_MUTE				4
+#define OUT1_MUTE				3
+#define LRCK_WIDTH				2
+#define TX_PDM					0
+
+
+/*I2S_TX1_CTRL1*/
+#define TX1_CHSEL				0
+
+/*I2S_TX1_CTRL2*/
+#define TX1_CH8_EN				7
+#define TX1_CH7_EN				6
+#define TX1_CH6_EN				5
+#define TX1_CH5_EN				4
+#define TX1_CH4_EN				3
+#define TX1_CH3_EN				2
+#define TX1_CH2_EN				1
+#define TX1_CH1_EN				0
+
+/*I2S_TX1_CTRL3*/
+#define TX1_CH16_EN				7
+#define TX1_CH15_EN				6
+#define TX1_CH14_EN				5
+#define TX1_CH13_EN				4
+#define TX1_CH12_EN				3
+#define TX1_CH11_EN				2
+#define TX1_CH10_EN				1
+#define TX1_CH9_EN				0
+
+/*I2S_TX1_CHMP_CTRL1*/
+#define TX1_CH4_MAP				6
+#define TX1_CH3_MAP				4
+#define TX1_CH2_MAP				2
+#define TX1_CH1_MAP				0
+
+/*I2S_TX1_CHMP_CTRL2*/
+#define TX1_CH8_MAP				6
+#define TX1_CH7_MAP				4
+#define TX1_CH6_MAP				2
+#define TX1_CH5_MAP				0
+
+/*I2S_TX1_CHMP_CTRL3*/
+#define TX1_CH12_MAP			6
+#define TX1_CH11_MAP			4
+#define TX1_CH10_MAP			2
+#define TX1_CH9_MAP				0
+
+/*I2S_TX1_CHMP_CTRL4*/
+#define TX1_CH16_MAP			6
+#define TX1_CH15_MAP			4
+#define TX1_CH14_MAP			2
+#define TX1_CH13_MAP			0
+
+
+/*I2S_TX2_CTRL1*/
+#define TX2_CHSEL				0
+
+/*I2S_TX2_CHMP_CTRL1*/
+#define TX2_CH4_MAP				6
+#define TX2_CH3_MAP				4
+#define TX2_CH2_MAP				2
+#define TX2_CH1_MAP				0
+
+/*I2S_TX2_CHMP_CTRL2*/
+#define TX2_CH8_MAP				6
+#define TX2_CH7_MAP				4
+#define TX2_CH6_MAP				2
+#define TX2_CH5_MAP				0
+
+/*I2S_TX2_CHMP_CTRL3*/
+#define TX2_CH12_MAP			6
+#define TX2_CH11_MAP			4
+#define TX2_CH10_MAP			2
+#define TX2_CH9_MAP				0
+
+/*I2S_TX2_CHMP_CTRL4*/
+#define TX2_CH16_MAP			6
+#define TX2_CH15_MAP			4
+#define TX2_CH14_MAP			2
+#define TX2_CH13_MAP			0
+
+
+/*I2S_RX1_CTRL1*/
+#define RX1_CHSEL				0
+
+/*I2S_RX1_CHMP_CTRL1*/
+#define RX1_CH4_MAP				6
+#define RX1_CH3_MAP				4
+#define RX1_CH2_MAP				2
+#define RX1_CH1_MAP				0
+
+/*I2S_RX1_CHMP_CTRL2*/
+#define RX1_CH8_MAP				6
+#define RX1_CH7_MAP				4
+#define RX1_CH6_MAP				2
+#define RX1_CH5_MAP				0
+
+/*I2S_RX1_CHMP_CTRL3*/
+#define RX1_CH12_MAP			6
+#define RX1_CH11_MAP			4
+#define RX1_CH10_MAP			2
+#define RX1_CH9_MAP				0
+
+/*I2S_RX1_CHMP_CTRL4*/
+#define RX1_CH16_MAP			6
+#define RX1_CH15_MAP			4
+#define RX1_CH14_MAP			2
+#define RX1_CH13_MAP			0
+
+
+/*I2S_LPB_DEBUG*/
+#define I2S_LPB_DEBUG_EN		0
+
+
+/*ADC_SPRC*/
+#define ADC_FS_I2S1				0
+
+/*ADC_DIG_EN*/
+#define DG_EN					4
+#define ENAD4					3
+#define ENAD3					2
+#define ENAD2					1
+#define ENAD1					0
+
+/*DMIC_EN*/
+#define DMIC2_EN				1
+#define DMIC1_EN				0
+
+/*ADC_DSR*/
+#define DIG_ADC4_SRS			6
+#define DIG_ADC3_SRS			4
+#define DIG_ADC2_SRS			2
+#define DIG_ADC1_SRS			0
+
+/*ADC_DDT_CTRL*/
+#define ADOUT_DLY_EN			2
+#define ADOUT_DTS				0
+
+
+/*HPF_EN*/
+#define DIG_ADC4_HPF_EN			3
+#define DIG_ADC3_HPF_EN			2
+#define DIG_ADC2_HPF_EN			1
+#define DIG_ADC1_HPF_EN			0
+
+
+/*ADC1_DMIX_SRC*/
+#define ADC1_ADC4_DMXL_GC		7
+#define ADC1_ADC3_DMXL_GC		6
+#define ADC1_ADC2_DMXL_GC		5
+#define ADC1_ADC1_DMXL_GC		4
+#define ADC1_ADC4_DMXL_SRC		3
+#define ADC1_ADC3_DMXL_SRC		2
+#define ADC1_ADC2_DMXL_SRC		1
+#define ADC1_ADC1_DMXL_SRC		0
+
+/*ADC2_DMIX_SRC*/
+#define ADC2_ADC4_DMXL_GC		7
+#define ADC2_ADC3_DMXL_GC		6
+#define ADC2_ADC2_DMXL_GC		5
+#define ADC2_ADC1_DMXL_GC		4
+#define ADC2_ADC4_DMXL_SRC		3
+#define ADC2_ADC3_DMXL_SRC		2
+#define ADC2_ADC2_DMXL_SRC		1
+#define ADC2_ADC1_DMXL_SRC		0
+
+/*ADC3_DMIX_SRC*/
+#define ADC3_ADC4_DMXL_GC		7
+#define ADC3_ADC3_DMXL_GC		6
+#define ADC3_ADC2_DMXL_GC		5
+#define ADC3_ADC1_DMXL_GC		4
+#define ADC3_ADC4_DMXL_SRC		3
+#define ADC3_ADC3_DMXL_SRC		2
+#define ADC3_ADC2_DMXL_SRC		1
+#define ADC3_ADC1_DMXL_SRC		0
+
+/*ADC4_DMIX_SRC*/
+#define ADC4_ADC4_DMXL_GC		7
+#define ADC4_ADC3_DMXL_GC		6
+#define ADC4_ADC2_DMXL_GC		5
+#define ADC4_ADC1_DMXL_GC		4
+#define ADC4_ADC4_DMXL_SRC		3
+#define ADC4_ADC3_DMXL_SRC		2
+#define ADC4_ADC2_DMXL_SRC		1
+#define ADC4_ADC1_DMXL_SRC		0
+
+
+/*ADC_DIG_DEBUG*/
+#define ADC_PTN_SEL				0
+
+
+/*I2S_DAT_PADDRV_CTRL*/
+#define TX2_DAT_DRV				4
+#define TX1_DAT_DRV				0
+
+/*I2S_CLK_PADDRV_CTRL*/
+#define LRCK_DRV				4
+#define BCLK_DRV				0
+
+
+/*ANA_PGA1_CTRL*/
+#define ADC1_ANALOG_PGA			1
+#define ADC1_ANALOG_PGA_STEP	0
+
+/*ANA_PGA2_CTRL*/
+#define ADC2_ANALOG_PGA			1
+#define ADC2_ANALOG_PGA_STEP	0
+
+/*ANA_PGA3_CTRL*/
+#define ADC3_ANALOG_PGA			1
+#define ADC3_ANALOG_PGA_STEP	0
+
+/*ANA_PGA4_CTRL*/
+#define ADC4_ANALOG_PGA			1
+#define ADC4_ANALOG_PGA_STEP	0
+
+
+/*MIC_OFFSET_CTRL1*/
+#define MIC_OFFSET_CAL_EN4		3
+#define MIC_OFFSET_CAL_EN3		2
+#define MIC_OFFSET_CAL_EN2		1
+#define MIC_OFFSET_CAL_EN1		0
+
+/*MIC_OFFSET_CTRL2*/
+#define MIC_OFFSET_CAL_GAIN		3
+#define MIC_OFFSET_CAL_CHANNEL	1
+#define MIC_OFFSET_CAL_EN_ONCE	0
+
+/*MIC1_OFFSET_STATU1*/
+#define MIC1_OFFSET_CAL_DONE	7
+#define MIC1_OFFSET_CAL_RUN_STA	6
+#define MIC1_OFFSET_MSB			0
+
+/*MIC1_OFFSET_STATU2*/
+#define MIC1_OFFSET_LSB			0
+
+/*MIC2_OFFSET_STATU1*/
+#define MIC2_OFFSET_CAL_DONE	7
+#define MIC2_OFFSET_CAL_RUN_STA	6
+#define MIC2_OFFSET_MSB			0
+
+/*MIC2_OFFSET_STATU2*/
+#define MIC2_OFFSET_LSB			0
+
+/*MIC3_OFFSET_STATU1*/
+#define MIC3_OFFSET_CAL_DONE	7
+#define MIC3_OFFSET_CAL_RUN_STA	6
+#define MIC3_OFFSET_MSB			0
+
+/*MIC3_OFFSET_STATU2*/
+#define MIC3_OFFSET_LSB			0
+
+/*MIC4_OFFSET_STATU1*/
+#define MIC4_OFFSET_CAL_DONE	7
+#define MIC4_OFFSET_CAL_RUN_STA	6
+#define MIC4_OFFSET_MSB			0
+
+/*MIC4_OFFSET_STATU2*/
+#define MIC4_OFFSET_LSB			0
+
+
+/*ANA_ADC1_CTRL1*/
+#define ADC1_PGA_BYPASS			7
+#define ADC1_PGA_BYP_RCM		6
+#define ADC1_PGA_CTRL_RCM		4
+#define ADC1_PGA_MUTE			3
+#define ADC1_DSM_ENABLE			2
+#define ADC1_PGA_ENABLE			1
+#define ADC1_MICBIAS_EN			0
+
+/*ANA_ADC1_CTRL3*/
+#define ADC1_ANA_CAL_EN			5
+#define ADC1_SEL_OUT_EDGE		3
+#define ADC1_DSM_DISABLE		2
+#define ADC1_VREFP_DISABLE		1
+#define ADC1_AAF_DISABLE		0
+
+/*ANA_ADC1_CTRL6*/
+#define PGA_CTRL_TC				6
+#define PGA_CTRL_RC				4
+#define PGA_CTRL_I_LIN			2
+#define PGA_CTRL_I_IN			0
+
+/*ANA_ADC1_CTRL7*/
+#define PGA_CTRL_HI_Z			7
+#define PGA_CTRL_SHORT_RF		6
+#define PGA_CTRL_VCM_VG			4
+#define PGA_CTRL_VCM_IN			0
+
+
+/*ANA_ADC2_CTRL1*/
+#define ADC2_PGA_BYPASS			7
+#define ADC2_PGA_BYP_RCM		6
+#define ADC2_PGA_CTRL_RCM		4
+#define ADC2_PGA_MUTE			3
+#define ADC2_DSM_ENABLE			2
+#define ADC2_PGA_ENABLE			1
+#define ADC2_MICBIAS_EN			0
+
+/*ANA_ADC2_CTRL3*/
+#define ADC2_ANA_CAL_EN			5
+#define ADC2_SEL_OUT_EDGE		3
+#define ADC2_DSM_DISABLE		2
+#define ADC2_VREFP_DISABLE		1
+#define ADC2_AAF_DISABLE		0
+
+/*ANA_ADC2_CTRL6*/
+#define PGA_CTRL_IBOOST			7
+#define PGA_CTRL_IQCTRL			6
+#define PGA_CTRL_OABIAS			4
+#define PGA_CTRL_CMLP_DIS		3
+#define PGA_CTRL_PDB_RIN		2
+#define PGA_CTRL_PEAKDET		0
+
+/*ANA_ADC2_CTRL7*/
+#define AAF_LPMODE_EN			7
+#define AAF_STG2_IB_SEL			4
+#define AAFDSM_IB_DIV2			3
+#define AAF_STG1_IB_SEL			0
+
+
+/*ANA_ADC3_CTRL1*/
+#define ADC3_PGA_BYPASS			7
+#define ADC3_PGA_BYP_RCM		6
+#define ADC3_PGA_CTRL_RCM		4
+#define ADC3_PGA_MUTE			3
+#define ADC3_DSM_ENABLE			2
+#define ADC3_PGA_ENABLE			1
+#define ADC3_MICBIAS_EN			0
+
+/*ANA_ADC3_CTRL3*/
+#define ADC3_ANA_CAL_EN			5
+#define ADC3_INVERT_CLK			4
+#define ADC3_SEL_OUT_EDGE		3
+#define ADC3_DSM_DISABLE		2
+#define ADC3_VREFP_DISABLE		1
+#define ADC3_AAF_DISABLE		0
+
+/*ANA_ADC3_CTRL7*/
+#define DSM_COMP_IB_SEL			6
+#define DSM_OTA_CTRL			4
+#define DSM_LPMODE				3
+#define DSM_OTA_IB_SEL			0
+
+
+/*ANA_ADC4_CTRL1*/
+#define ADC4_PGA_BYPASS			7
+#define ADC4_PGA_BYP_RCM		6
+#define ADC4_PGA_CTRL_RCM		4
+#define ADC4_PGA_MUTE			3
+#define ADC4_DSM_ENABLE			2
+#define ADC4_PGA_ENABLE			1
+#define ADC4_MICBIAS_EN			0
+
+/*ANA_ADC4_CTRL3*/
+#define ADC4_ANA_CAL_EN			5
+#define ADC4_SEL_OUT_EDGE		3
+#define ADC4_DSM_DISABLE		2
+#define ADC4_VREFP_DISABLE		1
+#define ADC4_AAF_DISABLE		0
+
+/*ANA_ADC4_CTRL6*/
+#define DSM_DEMOFF				5
+#define DSM_EN_DITHER			4
+#define DSM_VREFP_LPMODE		2
+#define DSM_VREFP_OUTCTRL		0
+
+/*ANA_ADC4_CTRL7*/
+#define CK8M_EN					5
+#define OSC_EN					4
+#define ADC4_CLK_GATING			3
+#define ADC3_CLK_GATING			2
+#define ADC2_CLK_GATING			1
+#define ADC1_CLK_GATING			0
+
+
+/*GPIO_CFG1*/
+#define GPIO2_SELECT			4
+#define GPIO1_SELECT			0
+
+/*GPIO_CFG2*/
+#define GPIO4_SELECT			4
+#define GPIO3_SELECT			0
+
+/*GPIO_DAT*///order???
+#define GPIO4_DAT				3
+#define GPIO3_DAT				2
+#define GPIO2_DAT				1
+#define GPIO1_DAT				0
+
+/*GPIO_DRV*/
+#define GPIO4_DRV				6
+#define GPIO3_DRV				4
+#define GPIO2_DRV				2
+#define GPIO1_DRV				0
+
+/*GPIO_PULL*/
+#define GPIO4_PULL				6
+#define GPIO3_PULL				4
+#define GPIO2_PULL				2
+#define GPIO1_PULL				0
+
+/*GPIO_INT_CFG*/
+#define GPIO4_EINT_CFG			6
+#define GPIO3_EINT_CFG			4
+#define GPIO2_EINT_CFG			2
+#define GPIO1_EINT_CFG			0
+
+/*GPIO_INT_EN*///order???
+#define GPIO4_EINT_EN			3
+#define GPIO3_EINT_EN			2
+#define GPIO2_EINT_EN			1
+#define GPIO1_EINT_EN			0
+
+/*GPIO_INT_STATUS*///order???
+#define GPIO4_EINT_STA			3
+#define GPIO3_EINT_STA			2
+#define GPIO2_EINT_STA			1
+#define GPIO1_EINT_STA			0
+
+
+/*PRNG_CLK_CTRL*/
+#define PRNG_CLK_EN				1
+#define PRNG_CLK_POS			0
+
+
+
+/*** Some Config Value ***/
+
+//[SYSCLK_CTRL]: PLLCLK_SRC
+#define PLLCLK_SRC_MCLK			0
+#define PLLCLK_SRC_BCLK			1
+#define PLLCLK_SRC_GPIO2		2
+#define PLLCLK_SRC_GPIO3		3
+
+//[SYSCLK_CTRL]: SYSCLK_SRC
+#define SYSCLK_SRC_MCLK			0
+#define SYSCLK_SRC_PLL			1
+
+//I2S BCLK POLARITY Control
+#define BCLK_NORMAL_DRIVE_N_SAMPLE_P	0
+#define BCLK_INVERT_DRIVE_P_SAMPLE_N	1
+
+//I2S LRCK POLARITY Control
+#define	LRCK_LEFT_LOW_RIGHT_HIGH		0
+#define LRCK_LEFT_HIGH_RIGHT_LOW		1
+
+//I2S Format Selection
+#define PCM_FORMAT						0
+#define LEFT_JUSTIFIED_FORMAT			1
+#define RIGHT_JUSTIFIED_FORMAT			2
+
+//ADC Digital Debug Control
+#define ADC_PTN_NORMAL					0
+#define ADC_PTN_0x5A5A5A				1
+#define ADC_PTN_0x123456				2
+#define ADC_PTN_ZERO					3
+#define ADC_PTN_I2S_RX_DATA				4
+
+//ADC PGA GAIN Control
+#define ADC_PGA_GAIN_0dB				0
+#define ADC_PGA_GAIN_MINUS_6dB			1
+#define ADC_PGA_GAIN_3dB				3
+#define ADC_PGA_GAIN_4dB				4
+#define ADC_PGA_GAIN_5dB				5
+#define ADC_PGA_GAIN_6dB				6
+#define ADC_PGA_GAIN_7dB				7
+#define ADC_PGA_GAIN_8dB				8
+#define ADC_PGA_GAIN_9dB				9
+#define ADC_PGA_GAIN_10dB				10
+#define ADC_PGA_GAIN_11dB				11
+#define ADC_PGA_GAIN_12dB				12
+#define ADC_PGA_GAIN_13dB				13
+#define ADC_PGA_GAIN_14dB				14
+#define ADC_PGA_GAIN_15dB				15
+#define ADC_PGA_GAIN_16dB				16
+#define ADC_PGA_GAIN_17dB				17
+#define ADC_PGA_GAIN_18dB				18
+#define ADC_PGA_GAIN_19dB				19
+#define ADC_PGA_GAIN_20dB				20
+#define ADC_PGA_GAIN_21dB				21
+#define ADC_PGA_GAIN_22dB				22
+#define ADC_PGA_GAIN_23dB				23
+#define ADC_PGA_GAIN_24dB				24
+#define ADC_PGA_GAIN_25dB				25
+#define ADC_PGA_GAIN_26dB				26
+#define ADC_PGA_GAIN_27dB				27
+#define ADC_PGA_GAIN_28dB				28
+#define ADC_PGA_GAIN_29dB				29
+#define ADC_PGA_GAIN_30dB				30
+
+
+#endif
+
-- 
2.7.4

